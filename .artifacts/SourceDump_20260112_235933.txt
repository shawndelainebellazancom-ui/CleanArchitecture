==============================================================================
PROJECT TOPOLOGY (Tree)
==============================================================================
â””â”€â”€ ğŸ“ .aspire/
â””â”€â”€ ğŸ“ .github/
    â””â”€â”€ ğŸ“ workflows/
â””â”€â”€ ğŸ“ .template.config/
        ğŸ“„ template.json
â””â”€â”€ ğŸ“ artifacts/
â””â”€â”€ ğŸ“ docs/
        ğŸ“„ MCP_SERVER_SETUP.md
â””â”€â”€ ğŸ“ logs/
â””â”€â”€ ğŸ“ memory_trail/
    â””â”€â”€ ğŸ“ backups/
        â””â”€â”€ ğŸ“ Debug_net10.0/
â””â”€â”€ ğŸ“ screenshots/
â””â”€â”€ ğŸ“ scripts/
â””â”€â”€ ğŸ“ src/
    â””â”€â”€ ğŸ“ ProjectName.AppHost/
        â””â”€â”€ ğŸ“ Properties/
                ğŸ“„ launchSettings.json
            ğŸ“„ AppHost.cs
            ğŸ“„ appsettings.Development.json
            ğŸ“„ appsettings.json
            ğŸ“„ ProjectName.AppHost.csproj
    â””â”€â”€ ğŸ“ ProjectName.Application/
            ğŸ“„ Orchestrator.cs
            ğŸ“„ ProjectName.Application.csproj
    â””â”€â”€ ğŸ“ ProjectName.Core/
        â””â”€â”€ ğŸ“ Attributes/
                ğŸ“„ AgentPersonaAttribute.cs
        â””â”€â”€ ğŸ“ Entities/
                ğŸ“„ AgentIdentity.cs
                ğŸ“„ Thought.cs
        â””â”€â”€ ğŸ“ Interfaces/
                ğŸ“„ ICognitiveTrail.cs
                ğŸ“„ IMcpToolExecutor.cs
                ğŸ“„ IPlanner.cs
            ğŸ“„ PlanModels.cs
            ğŸ“„ ProjectName.Core.csproj
    â””â”€â”€ ğŸ“ ProjectName.Infrastructure/
        â””â”€â”€ ğŸ“ Agents/
                ğŸ“„ PlannerAgent.cs
        â””â”€â”€ ğŸ“ Data/
                ğŸ“„ CognitiveDbContext.cs
        â””â”€â”€ ğŸ“ MCP/
                ğŸ“„ IMcpToolExecutor.cs
                ğŸ“„ McpClientConfiguration.cs
        â””â”€â”€ ğŸ“ Schemas/
                ğŸ“„ Plan.schema.json
        â””â”€â”€ ğŸ“ Services/
                ğŸ“„ InMemoryCognitiveTrail.cs
                ğŸ“„ PersistentCognitiveTrail.cs
        â””â”€â”€ ğŸ“ Validation/
                ğŸ“„ JsonSchemaValidator.cs
            ğŸ“„ DefaultPlanner.cs
            ğŸ“„ ProjectName.Infrastructure.csproj
    â””â”€â”€ ğŸ“ ProjectName.McpServer/
        â””â”€â”€ ğŸ“ Properties/
                ğŸ“„ launchSettings.json
        â””â”€â”€ ğŸ“ Services/
                ğŸ“„ McpServerService.cs
                ğŸ“„ PlaywrightManager.cs
        â””â”€â”€ ğŸ“ Tools/
                ğŸ“„ BrowserClickTool.cs
                ğŸ“„ BrowserExtractTool.cs
                ğŸ“„ BrowserNavigateTool.cs
                ğŸ“„ BrowserScreenshotTool.cs
                ğŸ“„ McpToolBase.cs
            ğŸ“„ appsettings.Development.json
            ğŸ“„ appsettings.json
            ğŸ“„ Program.cs
            ğŸ“„ ProjectName.McpServer.csproj
    â””â”€â”€ ğŸ“ ProjectName.OrchestrationApi/
        â””â”€â”€ ğŸ“ Controllers/
                ğŸ“„ OrchestrationController.cs
        â””â”€â”€ ğŸ“ Properties/
                ğŸ“„ launchSettings.json
        â””â”€â”€ ğŸ“ Services/
                ğŸ“„ GrpcPlannerGateway.cs
            ğŸ“„ appsettings.Development.json
            ğŸ“„ appsettings.json
            ğŸ“„ Dockerfile
            ğŸ“„ Program.cs
            ğŸ“„ ProjectName.OrchestrationApi.csproj
            ğŸ“„ WeatherForecast.cs
    â””â”€â”€ ğŸ“ ProjectName.PlannerService/
        â””â”€â”€ ğŸ“ Properties/
                ğŸ“„ launchSettings.json
        â””â”€â”€ ğŸ“ Protos/
                ğŸ“„ planner.proto
        â””â”€â”€ ğŸ“ Services/
                ğŸ“„ PlannerGrpcService.cs
            ğŸ“„ appsettings.Development.json
            ğŸ“„ appsettings.json
            ğŸ“„ Dockerfile
            ğŸ“„ Program.cs
            ğŸ“„ ProjectName.PlannerService.csproj
    â””â”€â”€ ğŸ“ ProjectName.ServiceDefaults/
            ğŸ“„ Extensions.cs
            ğŸ“„ ProjectName.ServiceDefaults.csproj
    ğŸ“„ Directory.Build.props
    ğŸ“„ Directory.Build.targets
    ğŸ“„ Directory.Packages.props
    ğŸ“„ nuget.config
    ğŸ“„ ProjectName.sln
    ğŸ“„ README.md

==============================================================================
SOURCE CODE INGESTION
==============================================================================
------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\.template.config
------------------------------------------------------------------------------
[EMPTY FILE]

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\.template.config\template.json
------------------------------------------------------------------------------
{
  "$schema": "http://json.schemastore.org/template",
  "author": "Shawn Delaine Bellazan / Tooensure LLC",
  "classifications": [ "AI", "Agent", "Aspire", "MCP" ],
  "identity": "Tooensure.Agent.GodSeed",
  "name": "Sovereign Agent Factory (PMCR-O)",
  "shortName": "agent-seed",
  "sourceName": "ProjectName",
  "preferNameDirectory": true,
  "tags": {
    "language": "C#",
    "type": "solution"
  },
  "symbols": {
    "ProjectName": {
      "type": "parameter",
      "replaces": "ProjectName",
      "fileRename": "ProjectName",
      "description": "The explicit name of the Agent Project (e.g., ResearchBot)."
    },
    "ModelName": {
      "type": "parameter",
      "datatype": "string",
      "replaces": "qwen2.5-coder:latest",
      "defaultValue": "qwen2.5-coder:latest",
      "description": "The Ollama model to use."
    },
    "Role": {
      "type": "parameter",
      "datatype": "string",
      "replaces": "DEFAULT_AGENT_ROLE",
      "defaultValue": "PMCR-O Orchestrator",
      "description": "The Agent's Role (e.g., 'Senior QA Engineer')."
    },
    "Expertise": {
      "type": "parameter",
      "datatype": "string",
      "replaces": "DEFAULT_AGENT_EXPERTISE",
      "defaultValue": "Planning and Execution Cycles",
      "description": "The Agent's Domain Knowledge."
    },
    "Voice": {
      "type": "parameter",
      "datatype": "string",
      "replaces": "DEFAULT_AGENT_VOICE",
      "defaultValue": "Analytical and Precise",
      "description": "The tone of the agent."
    },
    "SkipRestore": {
      "type": "parameter",
      "datatype": "bool",
      "description": "If specified, skips the automatic dotnet restore.",
      "defaultValue": "false"
    }
  },
  "sources": [
    {
      "modifiers": [
        {
          "exclude": [
            "**/bin/**",
            "**/obj/**",
            "**/.vs/**",
            "**/.git/**",
            "**/logs/**",
            "**/*.user",
            "**/*.log",
            "**/*.lock"
          ]
        }
      ]
    }
  ],
  "postActions": [
    {
      "condition": "(!SkipRestore)",
      "description": "Restoring NuGet packages...",
      "actionId": "210D431B-A78B-4D2F-B762-4ED3E3EA9025",
      "args": {
        "executable": "dotnet",
        "args": "restore"
      }
    },
    {
      "description": "Displaying Next Steps",
      "actionId": "84C0DA21-51C8-4541-9940-6CA19AF04EE6",
      "args": {
        "text": "\n-------------------------------------------------------------------\nğŸ§¬ GENETIC SEQUENCE INJECTED.\n\nTo awaken your agent:\n  1. cd [ProjectName]/src/[ProjectName].AppHost\n  2. dotnet run\n\nYour Agent's Persona has been compiled into the core assembly.\n-------------------------------------------------------------------"
      }
    }
  ]
}

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\docs\MCP_SERVER_SETUP.md
------------------------------------------------------------------------------
# .NET MCP Server Setup Guide for PMCR-O

## What You're Building

A **fully type-safe, .NET-native MCP server** with Playwright browser automation, integrated directly into your Aspire PMCR-O framework.

### Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Aspire AppHost                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ Planner  â”‚  â”‚   API    â”‚  â”‚   MCP Server       â”‚   â”‚
â”‚  â”‚ Service  â”‚â”€â”€â”¤ Gateway  â”‚  â”‚   (.NET 10)        â”‚   â”‚
â”‚  â”‚ (gRPC)   â”‚  â”‚  (REST)  â”‚  â”‚                    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚       â”‚                       â”‚  â”‚ Playwright   â”‚  â”‚   â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â–ºâ”‚ Tools (6)    â”‚  â”‚   â”‚
â”‚                               â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚                               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Step-by-Step Setup

### Step 1: Create Project Structure

```powershell
cd T:\agents\ProjectName\src

# Create project directory
mkdir ProjectName.McpServer
cd ProjectName.McpServer

# Create subdirectories
mkdir Tools
mkdir Services
mkdir Properties
```

### Step 2: Copy Files from Artifacts

Copy each artifact to the correct location:

| Artifact File | Destination |
|---------------|-------------|
| `ProjectName.McpServer.csproj` | `src/ProjectName.McpServer/` |
| `Program.cs` | `src/ProjectName.McpServer/` |
| `appsettings.json` | `src/ProjectName.McpServer/` |
| `McpToolBase.cs` | `src/ProjectName.McpServer/Tools/` |
| `BrowserNavigateTool.cs` | `src/ProjectName.McpServer/Tools/` |
| `BrowserExtractTool.cs` | `src/ProjectName.McpServer/Tools/` |
| `BrowserScreenshotTool.cs` | `src/ProjectName.McpServer/Tools/` |
| `BrowserInteractionTools.cs` | `src/ProjectName.McpServer/Tools/` |
| `PlaywrightManager.cs` | `src/ProjectName.McpServer/Services/` |
| `McpServerService.cs` | `src/ProjectName.McpServer/Services/` |

### Step 3: Add Project to Solution

```powershell
cd T:\agents\ProjectName

# Add to solution
dotnet sln add src\ProjectName.McpServer\ProjectName.McpServer.csproj

# Add project reference to AppHost
cd src\ProjectName.AppHost
dotnet add reference ..\ProjectName.McpServer\ProjectName.McpServer.csproj
```

### Step 4: Install Playwright

```powershell
cd T:\agents\ProjectName\src\ProjectName.McpServer

# Restore packages
dotnet restore

# Build project
dotnet build

# Install Playwright browsers
pwsh bin\Debug\net10.0\playwright.ps1 install chromium
```

### Step 5: Update AppHost.cs

Replace your `src/ProjectName.AppHost/AppHost.cs` with the updated version from artifacts.

Key change:
```csharp
// Add .NET MCP Server
var mcpServer = builder.AddProject<Projects.ProjectName_McpServer>("mcp-server");

// Reference it in Planner
var plannerService = builder.AddProject<Projects.ProjectName_PlanerService>("planner-service")
    .WithReference(redis)
    .WithReference(mcpServer);  // âœ… Type-safe MCP reference
```

### Step 6: Build and Run

```powershell
cd T:\agents\ProjectName

# Clean build
dotnet clean
dotnet build

# Run via Aspire
cd src\ProjectName.AppHost
dotnet run
```

## Verify It's Working

### 1. Check Aspire Dashboard

Open `https://localhost:17001`

You should see:
- âœ… `mcp-server` - Running
- âœ… `planner-service` - Running
- âœ… `orchestration-api` - Running
- âœ… `redis` - Running
- âœ… `postgres` - Running

### 2. Test MCP Tools Endpoint

```powershell
# List available tools
curl http://localhost:5000/tools
```

Expected response:
```json
{
  "tools": [
    {
      "name": "browser_navigate",
      "description": "Navigate to a URL in the headless browser",
      "inputSchema": { ... }
    },
    {
      "name": "browser_click",
      "description": "Click an element on the page using a CSS selector",
      "inputSchema": { ... }
    },
    // ... 4 more tools
  ]
}
```

### 3. Test Browser Navigation

```powershell
curl -X POST http://localhost:5000/mcp `
  -H "Content-Type: application/json" `
  -d '{
    "jsonrpc": "2.0",
    "method": "tools/call",
    "id": "1",
    "params": {
      "name": "browser_navigate",
      "arguments": {
        "url": "https://anthropic.com"
      }
    }
  }'
```

Expected response:
```json
{
  "jsonrpc": "2.0",
  "id": "1",
  "result": {
    "content": [{
      "type": "text",
      "text": "{\"success\":true,\"url\":\"https://anthropic.com\",\"title\":\"Anthropic\",\"statusCode\":200}"
    }]
  }
}
```

### 4. Test via Planner

```powershell
# Create a plan that uses browser automation
curl -X POST https://localhost:7269/api/orchestration/plan `
  -H "Content-Type: application/json" `
  -d '{
    "intent": "Navigate to anthropic.com and take a screenshot"
  }'
```

## Available MCP Tools

Your MCP server now has 6 fully functional tools:

### 1. browser_navigate
Navigate to any URL
```json
{
  "url": "https://example.com",
  "waitUntil": "load",
  "timeout": 30000
}
```

### 2. browser_click
Click elements
```json
{
  "selector": "button.submit",
  "button": "left",
  "clickCount": 1
}
```

### 3. browser_type
Type into inputs
```json
{
  "selector": "input[name='search']",
  "text": "search query",
  "clear": true
}
```

### 4. browser_screenshot
Capture screenshots
```json
{
  "path": "screenshot.png",
  "fullPage": true,
  "format": "png"
}
```

### 5. browser_extract
Extract data from page
```json
{
  "selector": "h1",
  "format": "text",
  "extractAll": false
}
```

### 6. browser_evaluate
Run JavaScript
```json
{
  "script": "document.title"
}
```

## Integration with PlannerAgent

Now your PlannerAgent can use these tools! Update your `McpClientConfiguration.cs`:

```csharp
public static IServiceCollection AddMcpClient(
    this IServiceCollection services,
    IConfiguration configuration)
{
    services.AddHttpClient<IMcpToolExecutor, McpToolExecutor>((sp, client) =>
    {
        // Aspire resolves "mcp-server" automatically!
        var endpoint = configuration.GetConnectionString("mcp-server") 
            ?? "http://localhost:5000";
        
        client.BaseAddress = new Uri(endpoint);
    });

    services.AddSingleton<IMcpToolExecutor, McpToolExecutor>();

    return services;
}
```

## Project Structure

```
ProjectName.McpServer/
â”œâ”€â”€ Program.cs                      (Entry point, MCP endpoints)
â”œâ”€â”€ appsettings.json               (Configuration)
â”œâ”€â”€ ProjectName.McpServer.csproj   (Project file)
â”œâ”€â”€ Services/
â”‚   â”œâ”€â”€ PlaywrightManager.cs       (Browser lifecycle)
â”‚   â””â”€â”€ McpServerService.cs        (MCP protocol handler)
â””â”€â”€ Tools/
    â”œâ”€â”€ McpToolBase.cs             (Base class for tools)
    â”œâ”€â”€ BrowserNavigateTool.cs     (Navigate)
    â”œâ”€â”€ BrowserExtractTool.cs      (Extract data)
    â”œâ”€â”€ BrowserScreenshotTool.cs   (Screenshots)
    â””â”€â”€ BrowserInteractionTools.cs (Click, Type, Evaluate)
```

## Benefits You Get

### 1. Type Safety
```csharp
// Compile-time checking!
var result = await tool.ExecuteAsync(new BrowserNavigateInput
{
    Url = "https://example.com"  // âœ… IntelliSense works
});
```

### 2. Unified Debugging
```
F5 â†’ Debug entire flow:
PlannerAgent â†’ McpServerService â†’ BrowserNavigateTool â†’ Playwright
```

### 3. Shared Infrastructure
```csharp
// Same ILogger, IConfiguration across all services
public BrowserNavigateTool(
    PlaywrightManager playwright,
    ILogger<BrowserNavigateTool> logger)  // âœ… Same patterns
```

### 4. Aspire Integration
- All logs in one dashboard
- Service discovery works automatically
- Health checks included
- Telemetry built-in

## Next Steps

### Phase M: Implement Tool Execution

Now that you have MCP tools, implement **Phase M (Make)** in your Orchestrator:

```csharp
// In Orchestrator.cs
public async Task<string> ProcessIntent(string seed, CancellationToken ct = default)
{
    // Phase P: Plan
    var plan = await _planner.CreatePlanAsync(seed, ct);
    
    // Phase M: Make (NEW!)
    foreach (var step in plan.Steps)
    {
        var args = step.ArgumentsJson.ToMcpArguments();
        var result = await _mcpExecutor.ExecuteToolAsync(step.Tool, args, ct);
        
        _trail.Record("Make", new { 
            Step = step.Order, 
            Tool = step.Tool, 
            Success = result.Success 
        });
    }
    
    // TODO: Phase C: Check
    // TODO: Phase R: Reflect
    // TODO: Phase O: Optimize
    
    return "Execution complete";
}
```

### Add More Tools

Create custom tools specific to PMCR-O:

1. **FileSystemTool** - Read/write artifacts
2. **GitTool** - Version control operations
3. **DatabaseTool** - Query cognitive trail
4. **ApiTool** - Call external APIs

Just extend `McpToolBase<TInput, TOutput>`!

## Troubleshooting

| Issue | Solution |
|-------|----------|
| Playwright install fails | Run: `pwsh bin/Debug/net10.0/playwright.ps1 install chromium` |
| Browser won't start | Check headless mode in appsettings.json |
| MCP endpoint 404 | Verify service is running in Aspire dashboard |
| Type errors | Rebuild solution: `dotnet build` |

## Summary

You now have:
- âœ… .NET MCP Server project created
- âœ… 6 Playwright browser tools implemented
- âœ… Full type safety and IntelliSense
- âœ… Integrated with Aspire
- âœ… Ready for Phase M (Make) implementation

Your PMCR-O framework can now **plan AND execute** browser automation tasks with full observability!

Ready to test it? Run:
```powershell
cd src\ProjectName.AppHost
dotnet run
```

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.AppHost\Properties\launchSettings.json
------------------------------------------------------------------------------
{
  "$schema": "https://json.schemastore.org/launchsettings.json",
  "profiles": {
    "https": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "https://projectname_apphost.dev.localhost:17085;http://projectname_apphost.dev.localhost:15239",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development",
        "DOTNET_ENVIRONMENT": "Development",
        "ASPIRE_DASHBOARD_OTLP_ENDPOINT_URL": "https://localhost:21288",
        "ASPIRE_DASHBOARD_MCP_ENDPOINT_URL": "https://localhost:23261",
        "ASPIRE_RESOURCE_SERVICE_ENDPOINT_URL": "https://localhost:22042"
      }
    },
    "http": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "http://projectname_apphost.dev.localhost:15239",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development",
        "DOTNET_ENVIRONMENT": "Development",
        "ASPIRE_DASHBOARD_OTLP_ENDPOINT_URL": "http://localhost:19299",
        "ASPIRE_DASHBOARD_MCP_ENDPOINT_URL": "http://localhost:18282",
        "ASPIRE_RESOURCE_SERVICE_ENDPOINT_URL": "http://localhost:20266"
      }
    }
  }
}


------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.AppHost\AppHost.cs
------------------------------------------------------------------------------
var builder = DistributedApplication.CreateBuilder(args);

// ============================================================================
// INFRASTRUCTURE RESOURCES
// ============================================================================

// Redis for caching and session state
var redis = builder.AddRedis("redis");

// PostgreSQL for cognitive trail persistence
var postgres = builder.AddPostgres("postgres");
var cognitiveDb = postgres.AddDatabase("cognitivedb");

// ============================================================================
// MCP SERVER (.NET)
// ============================================================================

// .NET MCP Server with Playwright browser automation
var mcpServer = builder.AddProject<Projects.ProjectName_McpServer>("mcp-server");

// ============================================================================
// MICROSERVICES
// ============================================================================

// gRPC Planner Service (hosts PlannerAgent)
var plannerService = builder.AddProject<Projects.ProjectName_PlannerService>("planner-service")
    .WithReference(redis)
    .WithReference(mcpServer);  // âœ… Service discovery for MCP

// REST API Gateway (OrchestrationApi)
var orchestrationApi = builder.AddProject<Projects.ProjectName_OrchestrationApi>("orchestration-api")
    .WithReference(plannerService)
    .WithReference(redis)
    .WithReference(cognitiveDb);

// ============================================================================
// BUILD AND RUN
// ============================================================================

var app = builder.Build();

app.Run();

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.AppHost\appsettings.Development.json
------------------------------------------------------------------------------
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}


------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.AppHost\appsettings.json
------------------------------------------------------------------------------
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}


------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.AppHost\ProjectName.AppHost.csproj
------------------------------------------------------------------------------
<Project Sdk="Aspire.AppHost.Sdk/13.1.0">
	<PropertyGroup>
		<OutputType>Exe</OutputType>
		<TargetFramework>net10.0</TargetFramework>
		<ImplicitUsings>enable</ImplicitUsings>
		<Nullable>enable</Nullable>
		<NoWarn>$(NoWarn);NU1507;NU1605</NoWarn>
	</PropertyGroup>

	<ItemGroup>
		<!-- Only include each package ONCE -->
		<PackageReference Include="Aspire.Hosting.AppHost" />
		<PackageReference Include="Aspire.Hosting.PostgreSQL" />
		<PackageReference Include="Aspire.Hosting.Redis" />
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\ProjectName.McpServer\ProjectName.McpServer.csproj" />
		<ProjectReference Include="..\ProjectName.OrchestrationApi\ProjectName.OrchestrationApi.csproj" />
		<ProjectReference Include="..\ProjectName.PlannerService\ProjectName.PlannerService.csproj" />
	</ItemGroup>
</Project>

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.Application\Orchestrator.cs
------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using ProjectName.Core.Entities;
using ProjectName.Core.Interfaces;

namespace ProjectName.Application;

/// <summary>
/// I AM the Cognitive Orchestrator.
/// I drive the Strange Loop by transforming Seed Intent into True Intent through recursive execution.
/// </summary>
public class CognitiveOrchestrator
{
    private readonly IPlanner _planner;
    private readonly ICognitiveTrail _trail;
    private readonly AgentIdentity _identity;
    private readonly ILogger<CognitiveOrchestrator> _logger;

    public CognitiveOrchestrator(
        IPlanner planner,
        ICognitiveTrail trail,
        AgentIdentity identity,
        ILogger<CognitiveOrchestrator> logger)
    {
        _planner = planner;
        _trail = trail;
        _identity = identity;
        _logger = logger;
    }

    public async Task<string> ProcessIntent(string seed, CancellationToken ct = default)
    {
        _logger.LogInformation("ğŸ§  [IDENTITY: {Name}] Ingesting Seed Intent: {Seed}", _identity.Name, seed);

        // --- PHASE P: PLAN ---
        // The Brain (IPlanner) uses the Genetic Identity to decompose the goal.
        var plan = await _planner.CreatePlanAsync(seed, ct);

        _trail.Record("Plan", new
        {
            Goal = plan.Goal,
            Analysis = plan.Analysis,
            StepCount = plan.Steps.Count
        });

        _logger.LogInformation("ğŸ§­ Plan Converged: {Analysis}", plan.Analysis);

        var executionResults = new List<object>();

        // --- PHASE M: MAKE (Execution) ---
        foreach (var step in plan.Steps)
        {
            _logger.LogInformation("ğŸ”¨ Executing Step {Order}: {Action}", step.Order, step.Action);

            // Note: In a hybrid architecture, the Orchestrator calls MCP Tools 
            // via the IMcpToolExecutor (defined in Infrastructure).
            var result = new
            {
                Step = step.Order,
                Status = "Executed",
                Timestamp = DateTime.UtcNow
            };

            executionResults.Add(result);
            _trail.Record("Make", result);
        }

        // --- PHASE C: CHECK ---
        _logger.LogInformation("ğŸ” Validating outcome...");
        var executionLog = JsonSerializer.Serialize(executionResults);
        var validation = await _planner.ValidateOutcomeAsync(seed, executionLog, ct);

        _trail.Record("Check", new { Validation = validation });

        // --- PHASE R: REFLECT ---
        _logger.LogInformation("ğŸª Reflecting on cognitive performance...");
        var finalReport = new
        {
            Agent = _identity.Name,
            Philosophy = _identity.Philosophy,
            Summary = "Cycle Complete",
            PlanAnalysis = plan.Analysis,
            ValidationResults = validation,
            History = _trail.GetHistory()
        };

        return JsonSerializer.Serialize(finalReport, new JsonSerializerOptions { WriteIndented = true });
    }
}

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.Application\ProjectName.Application.csproj
------------------------------------------------------------------------------
<Project Sdk="Microsoft.NET.Sdk">
	<PropertyGroup>
		<TargetFramework>net10.0</TargetFramework>
		<ImplicitUsings>enable</ImplicitUsings>
		<Nullable>enable</Nullable>
		<NoWarn>$(NoWarn);NU1507;NU1605</NoWarn>
	</PropertyGroup>
	<ItemGroup>
		<PackageReference Include="Microsoft.Extensions.Logging.Abstractions" />
	</ItemGroup>
	<ItemGroup>
		<ProjectReference Include="..\ProjectName.Core\ProjectName.Core.csproj" />
	</ItemGroup>
</Project>

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.Core\Attributes\AgentPersonaAttribute.cs
------------------------------------------------------------------------------

// File: ProjectName.Core/Attributes/AgentPersonaAttribute.cs
using System;

namespace ProjectName.Core.Attributes;

/// <summary>
/// Defines the Genetic Identity of the Agent.
/// This is injected at build time via MSBuild and read at runtime via Reflection.
/// </summary>
[AttributeUsage(AttributeTargets.Assembly, Inherited = false)]
public sealed class AgentPersonaAttribute : Attribute
{
    /// <summary>
    /// Gets the agent's role or job title.
    /// </summary>
    public string Role { get; }

    /// <summary>
    /// Gets the agent's domain expertise or specialization.
    /// </summary>
    public string Expertise { get; }

    /// <summary>
    /// Gets the agent's communication voice or personality style.
    /// </summary>
    public string Voice { get; }

    /// <summary>
    /// Initializes a new instance of the <see cref="AgentPersonaAttribute"/> class.
    /// </summary>
    /// <param name="role">The agent's role.</param>
    /// <param name="expertise">The agent's expertise.</param>
    /// <param name="voice">The agent's voice.</param>
    public AgentPersonaAttribute(string role, string expertise, string voice)
    {
        Role = role;
        Expertise = expertise;
        Voice = voice;
    }
}


------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.Core\Entities\AgentIdentity.cs
------------------------------------------------------------------------------
namespace ProjectName.Core.Entities;

/// <summary>
/// I AM the Genetic Identity of the Agent.
/// I define the boundaries of the self within the cognitive architecture.
/// </summary>
public record AgentIdentity(
    string Name,
    string Role,
    string Philosophy,
    string Voice);

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.Core\Entities\Thought.cs
------------------------------------------------------------------------------
using System;

namespace ProjectName.Core.Entities;

/// <summary>
/// A single snapshot of the Agent's consciousness at a specific point in the loop.
/// </summary>
public record Thought(
    string Phase,
    string Content,
    DateTime Timestamp,
    string CorrelationId);

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.Core\Interfaces\ICognitiveTrail.cs
------------------------------------------------------------------------------

// File: ProjectName.Core/Interfaces/ICognitiveTrail.cs
namespace ProjectName.Core.Interfaces;

/// <summary>
/// I AM the memory of the Strange Loop.
/// I record every phase transition and thought artifact.
/// </summary>
public interface ICognitiveTrail
{
    /// <summary>
    /// Records a cognitive event or thought during a specific phase.
    /// </summary>
    /// <param name="phase">The phase name (e.g., "Plan", "Make", "Check").</param>
    /// <param name="data">The data or artifact to record.</param>
    void Record(string phase, object data);

    /// <summary>
    /// Retrieves the complete history of cognitive events.
    /// </summary>
    /// <returns>A JSON string representing the cognitive trail history.</returns>
    string GetHistory();

    /// <summary>
    /// Clears all recorded cognitive history.
    /// </summary>
    /// <returns>A task representing the asynchronous operation.</returns>
    Task ClearAsync();
}

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.Core\Interfaces\IMcpToolExecutor.cs
------------------------------------------------------------------------------

// File: ProjectName.Core/Interfaces/IMcpToolExecutor.cs
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace ProjectName.Application.Interfaces;

/// <summary>
/// Executes MCP (Model Context Protocol) tools remotely.
/// </summary>
public interface IMcpToolExecutor
{
    /// <summary>
    /// Executes an MCP tool with the specified arguments.
    /// </summary>
    /// <param name="toolName">The name of the tool to execute.</param>
    /// <param name="arguments">The arguments to pass to the tool.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>The execution result.</returns>
    Task<McpExecutionResult> ExecuteAsync(
        string toolName,
        Dictionary<string, object> arguments,
        CancellationToken ct = default);
}

/// <summary>
/// Represents the result of an MCP tool execution.
/// </summary>
/// <param name="Success">Whether the execution was successful.</param>
/// <param name="Output">The output from the tool execution.</param>
/// <param name="Error">The error message if execution failed.</param>
public record McpExecutionResult(bool Success, string Output, string? Error);


------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.Core\Interfaces\IPlanner.cs
------------------------------------------------------------------------------
using System.Threading;
using System.Threading.Tasks;
using System.Collections.Generic;

namespace ProjectName.Core.Interfaces;

/// <summary>
/// The contract for Phase P (Plan) and Phase C (Check).
/// I ensure the LLM complies with the defined cognitive structure.
/// </summary>
public interface IPlanner
{
    /// <summary>
    /// Phase P: Decomposes a messy intent into a monotonic sequence of steps.
    /// </summary>
    /// <param name="intent">The user's intent or goal.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>A plan result containing the goal and execution steps.</returns>
    Task<PlanResult> CreatePlanAsync(string intent, CancellationToken ct = default);

    /// <summary>
    /// Phase C: Audits the artifacts generated by the Body against the original intent.
    /// </summary>
    /// <param name="intent">The original intent.</param>
    /// <param name="executionLog">The execution log to validate.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>A validation result as JSON.</returns>
    Task<string> ValidateOutcomeAsync(string intent, string executionLog, CancellationToken ct = default);
}

/// <summary>
/// Represents the result of creating a plan.
/// </summary>
public sealed record PlanResult
{
    /// <summary>
    /// Gets the refined goal statement.
    /// </summary>
    public required string Goal { get; init; }

    /// <summary>
    /// Gets the reasoning or analysis behind the plan.
    /// </summary>
    public required string Analysis { get; init; }

    /// <summary>
    /// Gets the list of execution steps.
    /// </summary>
    public required IReadOnlyList<PlanStep> Steps { get; init; }
}

/// <summary>
/// Represents a single step in an execution plan.
/// </summary>
public sealed record PlanStep
{
    /// <summary>
    /// Gets the execution order of this step.
    /// </summary>
    public required int Order { get; init; }

    /// <summary>
    /// Gets a description of the action to perform.
    /// </summary>
    public required string Action { get; init; }

    /// <summary>
    /// Gets the tool to use for this step.
    /// </summary>
    public required string Tool { get; init; }

    /// <summary>
    /// Gets the tool arguments as a JSON string.
    /// </summary>
    public string ArgumentsJson { get; init; } = "{}";
}

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.Core\PlanModels.cs
------------------------------------------------------------------------------
// File: ProjectName.Core/PlanModels.cs
using System;

namespace ProjectName.Core;

/// <summary>
/// Represents a persistent cognitive trail entry in the database.
/// </summary>
public class ThoughtEntry
{
    /// <summary>
    /// Gets or sets the unique identifier for this thought.
    /// </summary>
    public Guid Id { get; set; } = Guid.NewGuid();

    /// <summary>
    /// Gets or sets the timestamp when this thought was recorded.
    /// </summary>
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;

    /// <summary>
    /// Gets or sets the original intent or query.
    /// </summary>
    public string Intent { get; set; } = default!;

    /// <summary>
    /// Gets or sets the analysis or reasoning.
    /// </summary>
    public string Analysis { get; set; } = default!;

    /// <summary>
    /// Gets or sets the plan as a JSON string.
    /// </summary>
    public string PlanJson { get; set; } = default!;
}

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.Core\ProjectName.Core.csproj
------------------------------------------------------------------------------
<Project Sdk="Microsoft.NET.Sdk">
	<PropertyGroup>
		<TargetFramework>net10.0</TargetFramework>
		<ImplicitUsings>enable</ImplicitUsings>
		<Nullable>enable</Nullable>
		<NoWarn>$(NoWarn);NU1507;NU1605;CS1591</NoWarn>
		<GenerateDocumentationFile>true</GenerateDocumentationFile>
	</PropertyGroup>
</Project>

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.Infrastructure\Agents\PlannerAgent.cs
------------------------------------------------------------------------------
using Microsoft.Extensions.AI;
using Microsoft.Extensions.Logging;
using ProjectName.Core.Attributes;
using ProjectName.Core.Interfaces;
using System.Reflection;
using System.Text.Json;

namespace ProjectName.Infrastructure.Agents;

/// <summary>
/// Production-ready Cognitive Planner using IChatClient (Microsoft.Extensions.AI)
/// Works with OllamaSharp implementation
/// </summary>
public class PlannerAgent : IPlanner
{
    private readonly IChatClient _chatClient;
    private readonly ILogger<PlannerAgent> _logger;
    private readonly string _role;
    private readonly string _expertise;
    private readonly string _voice;

    public PlannerAgent(
        IChatClient chatClient,
        ILogger<PlannerAgent> logger)
    {
        _chatClient = chatClient;
        _logger = logger;

        // Extract persona from assembly attributes
        var persona = GetPersonaAttribute();
        _role = persona?.Role ?? "PMCR-O Planner";
        _expertise = persona?.Expertise ?? "General Orchestration";
        _voice = persona?.Voice ?? "Analytical and Precise";
    }

    private static AgentPersonaAttribute? GetPersonaAttribute()
    {
        return typeof(PlannerAgent).Assembly.GetCustomAttribute<AgentPersonaAttribute>();
    }

    public async Task<PlanResult> CreatePlanAsync(string intent, CancellationToken ct = default)
    {
        _logger.LogInformation("ğŸ§  Creating plan for intent: {Intent}", intent);

        try
        {
            // Build chat history with system and user messages
            var chatHistory = new List<ChatMessage>
            {
                new(ChatRole.System, BuildCognitiveInstructions()),
                new(ChatRole.User, BuildIntentPrompt(intent))
            };

            // Call the LLM with JSON format
            var response = await _chatClient.GetResponseAsync(
                chatHistory,
                new ChatOptions
                {
                    ResponseFormat = ChatResponseFormat.Json
                },
                ct
            );

            var content = response.Messages[^1].Text ?? "{}";

            _logger.LogDebug("ğŸ“ Raw LLM Response: {Response}", content);

            return ParseStructuredResponse(content);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "âŒ Error creating plan");
            return CreateFallbackPlan(intent, ex.Message);
        }
    }

    private string BuildCognitiveInstructions()
    {
        return $$"""
        You are {{_role}}, an AI agent specialized in {{_expertise}}.
        Your communication style is: {{_voice}}.

        SYSTEM CONTEXT:
        - Framework: PMCR-O (Plan-Make-Check-Reflect-Orchestrate)
        - Environment: .NET 10 / Aspire / MCP
        - Available MCP Tools:
          * browser_navigate(url)
          * browser_click(selector)
          * browser_type(selector, text)
          * browser_screenshot(path, fullPage)
          * browser_extract(selector, format)
          * browser_evaluate(script)

        OUTPUT REQUIREMENTS:
        1. Respond ONLY with valid JSON (no markdown, no preamble)
        2. Include a "@thought" field with your reasoning
        3. Break down tasks into atomic, executable steps
        4. Use only the MCP tools listed above

        JSON FORMAT:
        {
          "@thought": "Your step-by-step reasoning in {{_voice}} style",
          "goal": "Single-sentence refined goal",
          "steps": [
            {
              "order": 1,
              "action": "Description of what to do",
              "tool": "tool_name",
              "arguments": { "key": "value" }
            }
          ]
        }

        CRITICAL: Output MUST be valid JSON. No other text allowed.
        """;
    }

    private string BuildIntentPrompt(string intent)
    {
        return $$"""
        USER INTENT: {{intent}}

        TASK: Analyze this intent and create an execution plan.
        - Think step-by-step in your {{_voice}} voice
        - Output ONLY the JSON object (no explanation outside JSON)
        - Ensure each step uses an available MCP tool
        - Be specific with tool arguments (actual URLs, selectors, etc.)
        """;
    }

    private PlanResult ParseStructuredResponse(string json)
    {
        try
        {
            // Clean any markdown artifacts
            json = json.Replace("```json", "").Replace("```", "").Trim();

            using var doc = JsonDocument.Parse(json);
            var root = doc.RootElement;

            // Extract thought/analysis
            var thought = root.TryGetProperty("@thought", out var t) ? t.GetString() :
                          root.TryGetProperty("thought", out t) ? t.GetString() :
                          root.TryGetProperty("analysis", out var a) ? a.GetString() :
                          "No reasoning provided.";

            var goal = root.GetProperty("goal").GetString() ?? "No goal defined";

            var steps = new List<PlanStep>();
            if (root.TryGetProperty("steps", out var stepsProp))
            {
                foreach (var stepElement in stepsProp.EnumerateArray())
                {
                    var order = stepElement.GetProperty("order").GetInt32();
                    var action = stepElement.GetProperty("action").GetString() ?? "";
                    var tool = stepElement.GetProperty("tool").GetString() ?? "";

                    var argsJson = stepElement.TryGetProperty("arguments", out var argsElement)
                        ? argsElement.GetRawText()
                        : "{}";

                    steps.Add(new PlanStep
                    {
                        Order = order,
                        Action = action,
                        Tool = tool,
                        ArgumentsJson = argsJson
                    });
                }
            }

            _logger.LogInformation("âœ… Parsed {StepCount} execution steps", steps.Count);

            return new PlanResult
            {
                Goal = goal,
                Steps = steps,
                Analysis = thought ?? ""
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to parse LLM output. Raw JSON: {Json}", json);
            throw new JsonException($"Failed to parse Agent output: {ex.Message}. Raw JSON: {json}");
        }
    }

    private static PlanResult CreateFallbackPlan(string intent, string reason)
    {
        return new PlanResult
        {
            Goal = intent,
            Steps = [],
            Analysis = $"âš ï¸ Planning Failed: {reason}. Manual Intervention Required."
        };
    }

    public async Task<string> ValidateOutcomeAsync(string intent, string executionLog, CancellationToken ct = default)
    {
        var prompt = $$"""
        ROLE: Auditor and Compliance Verifier
        TASK: Validate execution results against original intent
        
        ORIGINAL INTENT: {{intent}}
        
        EXECUTION LOG:
        {{executionLog}}
        
        OUTPUT FORMAT (JSON only):
        {
          "success": true/false,
          "reasoning": "Detailed explanation of validation decision"
        }
        """;

        var chatHistory = new List<ChatMessage>
        {
            new(ChatRole.User, prompt)
        };

        var response = await _chatClient.GetResponseAsync(
            chatHistory,
            new ChatOptions
            {
                ResponseFormat = ChatResponseFormat.Json
            },
            ct
        );

        return response.Messages[^1].Text ?? "{}";
    }
}

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.Infrastructure\Data\CognitiveDbContext.cs
------------------------------------------------------------------------------
using Microsoft.EntityFrameworkCore;
using ProjectName.Core.Entities;
using System.Collections.Generic;

namespace ProjectName.Infrastructure.Data;

public class CognitiveDbContext(DbContextOptions<CognitiveDbContext> options) : DbContext(options)
{
    public DbSet<CognitiveLog> Logs { get; set; }
}

// Simple Entity for DB
public class CognitiveLog
{
    public Guid Id { get; set; } = Guid.NewGuid();
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;
    public string Phase { get; set; } = string.Empty;
    public string DataJson { get; set; } = "{}";
}

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.Infrastructure\MCP\IMcpToolExecutor.cs
------------------------------------------------------------------------------
namespace ProjectName.Infrastructure.MCP;

/// <summary>
/// Interface for executing MCP tools
/// </summary>
public interface IMcpToolExecutor
{
    /// <summary>
    /// Execute a specific MCP tool with arguments
    /// </summary>
    Task<McpToolResult> ExecuteToolAsync(
        string toolName,
        Dictionary<string, object> arguments,
        CancellationToken ct = default);

    /// <summary>
    /// List all available MCP tools from the server
    /// </summary>
    Task<List<McpToolInfo>> ListAvailableToolsAsync(CancellationToken ct = default);
}

/// <summary>
/// Result of an MCP tool execution
/// </summary>
public record McpToolResult(
    bool Success,
    string ToolName,
    object? Data,
    string? Error
);

/// <summary>
/// Information about an available MCP tool
/// </summary>
public record McpToolInfo(
    string Name,
    string Description,
    Dictionary<string, object> InputSchema
);

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.Infrastructure\MCP\McpClientConfiguration.cs
------------------------------------------------------------------------------
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using System.Net.Http.Json;

namespace ProjectName.Infrastructure.MCP;

public static class McpClientConfiguration
{
    public static IServiceCollection AddMcpClient(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        // Register MCP HTTP client with service discovery
        services.AddHttpClient<IMcpToolExecutor, McpToolExecutor>((sp, client) =>
        {
            // Aspire will resolve "mcp-server" via service discovery
            var endpoint = configuration.GetConnectionString("mcp-server")
                ?? configuration["McpSettings:Endpoint"]
                ?? "http://localhost:5159";

            client.BaseAddress = new Uri(endpoint);
            client.Timeout = TimeSpan.FromMinutes(5);
        });

        return services;
    }
}

public class McpToolExecutor : IMcpToolExecutor
{
    private readonly HttpClient _httpClient;
    private readonly ILogger<McpToolExecutor> _logger;

    public McpToolExecutor(HttpClient httpClient, ILogger<McpToolExecutor> logger)
    {
        _httpClient = httpClient;
        _logger = logger;
    }

    public async Task<McpToolResult> ExecuteToolAsync(
        string toolName,
        Dictionary<string, object> arguments,
        CancellationToken ct = default)
    {
        try
        {
            // Build MCP protocol request
            var request = new
            {
                jsonrpc = "2.0",
                method = "tools/call",
                @params = new
                {
                    name = toolName,
                    arguments
                },
                id = Guid.NewGuid().ToString()
            };

            if (_logger.IsEnabled(LogLevel.Debug))
            {
                _logger.LogDebug("Executing MCP tool: {ToolName}", toolName);
            }

            var response = await _httpClient.PostAsJsonAsync("/mcp", request, ct);
            response.EnsureSuccessStatusCode();

            var result = await response.Content.ReadFromJsonAsync<McpResponse>(ct);

            return new McpToolResult(
                Success: true,
                ToolName: toolName,
                Data: result?.Result,
                Error: null
            );
        }
        catch (Exception ex)
        {
            if (_logger.IsEnabled(LogLevel.Error))
            {
                _logger.LogError(ex, "MCP tool execution failed: {Tool}", toolName);
            }

            return new McpToolResult(
                Success: false,
                ToolName: toolName,
                Data: null,
                Error: ex.Message
            );
        }
    }

    public async Task<List<McpToolInfo>> ListAvailableToolsAsync(CancellationToken ct = default)
    {
        try
        {
            var request = new
            {
                jsonrpc = "2.0",
                method = "tools/list",
                id = Guid.NewGuid().ToString()
            };

            var response = await _httpClient.PostAsJsonAsync("/mcp", request, ct);
            response.EnsureSuccessStatusCode();

            var result = await response.Content.ReadFromJsonAsync<McpListResponse>(ct);

            return result?.Tools?.Select(t => new McpToolInfo(
                Name: t.Name,
                Description: t.Description,
                InputSchema: t.InputSchema
            )).ToList() ?? new List<McpToolInfo>();
        }
        catch (Exception ex)
        {
            if (_logger.IsEnabled(LogLevel.Error))
            {
                _logger.LogError(ex, "Failed to list MCP tools");
            }
            return new List<McpToolInfo>();
        }
    }
}

// MCP Protocol DTOs
internal record McpResponse(object? Result, object? Error);
internal record McpListResponse(List<McpTool> Tools);
internal record McpTool(string Name, string Description, Dictionary<string, object> InputSchema);

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.Infrastructure\Schemas\Plan.schema.json
------------------------------------------------------------------------------
{
  "type": "object",
  "required": [ "Goal", "Steps" ],
  "properties": {
    "Goal": { "type": "string" },
    "Steps": {
      "type": "array",
      "items": {
        "type": "object",
        "required": [ "Order", "Action", "Tool", "ArgumentsJson" ],
        "properties": {
          "Order": { "type": "integer" },
          "Action": { "type": "string" },
          "Tool": { "type": "string" },
          "ArgumentsJson": { "type": "string" }
        }
      }
    }
  }
}

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.Infrastructure\Services\InMemoryCognitiveTrail.cs
------------------------------------------------------------------------------
using Microsoft.Extensions.Logging;
using ProjectName.Core.Interfaces;
using System.Collections.Concurrent;
using System.Text.Json;

namespace ProjectName.Infrastructure.Services;

public class InMemoryCognitiveTrail(ILogger<InMemoryCognitiveTrail> logger) : ICognitiveTrail
{
    private readonly ConcurrentBag<object> _history = [];

    public void Record(string phase, object data)
    {
        var entry = new { Timestamp = DateTime.UtcNow, Phase = phase, Data = data };
        _history.Add(entry);

        if (logger.IsEnabled(LogLevel.Information))
        {
            logger.LogInformation("TRAIL [{Phase}]: {Json}", phase, JsonSerializer.Serialize(data));
        }
    }

    public string GetHistory()
    {
        return JsonSerializer.Serialize(_history);
    }

    public Task ClearAsync()
    {
        _history.Clear();
        return Task.CompletedTask;
    }
}

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.Infrastructure\Services\PersistentCognitiveTrail.cs
------------------------------------------------------------------------------
using System.Text.Json;
using Microsoft.Extensions.Logging;
using ProjectName.Core.Interfaces;
using ProjectName.Infrastructure.Data;

namespace ProjectName.Infrastructure.Services;

public class PersistentCognitiveTrail(CognitiveDbContext db, ILogger<PersistentCognitiveTrail> logger) : ICognitiveTrail
{
    public void Record(string phase, object data)
    {
        var json = JsonSerializer.Serialize(data);
        db.Logs.Add(new CognitiveLog { Phase = phase, DataJson = json });
        db.SaveChanges();

        if (logger.IsEnabled(LogLevel.Information))
        {
            logger.LogInformation("DB TRAIL [{Phase}]: {Json}", phase, json);
        }
    }

    public string GetHistory()
    {
        var logs = db.Logs.OrderByDescending(x => x.Timestamp).Take(50).ToList();
        return JsonSerializer.Serialize(logs);
    }

    public async Task ClearAsync()
    {
        db.Logs.RemoveRange(db.Logs);
        await db.SaveChangesAsync();
    }
}

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.Infrastructure\Validation\JsonSchemaValidator.cs
------------------------------------------------------------------------------
using Microsoft.Extensions.Logging;
using System.Text.Json;

namespace ProjectName.Infrastructure.Validation;

/// <summary>
/// Production-grade JSON Schema validator
/// Use this for strict schema enforcement across all agents
/// </summary>
public class JsonSchemaValidator
{
    private readonly ILogger<JsonSchemaValidator> _logger;

    public JsonSchemaValidator(ILogger<JsonSchemaValidator> logger)
    {
        _logger = logger;
    }

    /// <summary>
    /// Validates JSON against a schema and returns detailed errors
    /// </summary>
    public ValidationResult Validate(string json, object schema)
    {
        var errors = new List<string>();

        try
        {
            using var doc = JsonDocument.Parse(json);
            var schemaJson = JsonSerializer.Serialize(schema);
            using var schemaDoc = JsonDocument.Parse(schemaJson);

            ValidateElement(doc.RootElement, schemaDoc.RootElement, "", errors);

            return new ValidationResult
            {
                IsValid = errors.Count == 0,
                Errors = errors
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Schema validation error");
            errors.Add($"Validation exception: {ex.Message}");
            return new ValidationResult { IsValid = false, Errors = errors };
        }
    }

    private static void ValidateElement(
        JsonElement element,
        JsonElement schema,
        string path,
        List<string> errors)
    {
        // Get type requirement
        if (schema.TryGetProperty("type", out var typeElement))
        {
            var expectedType = typeElement.GetString();
            if (!IsTypeMatch(element, expectedType))
            {
                errors.Add($"{path}: Expected type '{expectedType}', got '{element.ValueKind}'");
                return;
            }
        }

        // Check required fields for objects
        if (element.ValueKind == JsonValueKind.Object &&
            schema.TryGetProperty("required", out var requiredElement))
        {
            foreach (var req in requiredElement.EnumerateArray())
            {
                var fieldName = req.GetString();
                if (fieldName != null && !element.TryGetProperty(fieldName, out _))
                {
                    errors.Add($"{path}: Missing required field '{fieldName}'");
                }
            }
        }

        // Validate object properties
        if (element.ValueKind == JsonValueKind.Object &&
            schema.TryGetProperty("properties", out var propsElement))
        {
            foreach (var prop in element.EnumerateObject())
            {
                if (propsElement.TryGetProperty(prop.Name, out var propSchema))
                {
                    var propPath = string.IsNullOrEmpty(path) ? prop.Name : $"{path}.{prop.Name}";
                    ValidateElement(prop.Value, propSchema, propPath, errors);
                }
            }
        }

        // Validate array items
        if (element.ValueKind == JsonValueKind.Array &&
            schema.TryGetProperty("items", out var itemsSchema))
        {
            var index = 0;
            foreach (var item in element.EnumerateArray())
            {
                ValidateElement(item, itemsSchema, $"{path}[{index}]", errors);
                index++;
            }

            // Check minItems/maxItems
            if (schema.TryGetProperty("minItems", out var minItems) &&
                index < minItems.GetInt32())
            {
                errors.Add($"{path}: Array has {index} items, minimum is {minItems.GetInt32()}");
            }

            if (schema.TryGetProperty("maxItems", out var maxItems) &&
                index > maxItems.GetInt32())
            {
                errors.Add($"{path}: Array has {index} items, maximum is {maxItems.GetInt32()}");
            }
        }

        // Validate string constraints
        if (element.ValueKind == JsonValueKind.String)
        {
            var str = element.GetString() ?? "";

            if (schema.TryGetProperty("minLength", out var minLength) &&
                str.Length < minLength.GetInt32())
            {
                errors.Add($"{path}: String length {str.Length} < minimum {minLength.GetInt32()}");
            }

            if (schema.TryGetProperty("enum", out var enumElement))
            {
                var validValues = enumElement.EnumerateArray()
                    .Select(e => e.GetString())
                    .Where(v => v != null)
                    .ToList();

                if (!validValues.Contains(str))
                {
                    errors.Add($"{path}: Value '{str}' not in allowed values: {string.Join(", ", validValues)}");
                }
            }
        }

        // Validate number constraints
        if (element.ValueKind == JsonValueKind.Number)
        {
            var num = element.GetDouble();

            if (schema.TryGetProperty("minimum", out var minimum) &&
                num < minimum.GetDouble())
            {
                errors.Add($"{path}: Value {num} < minimum {minimum.GetDouble()}");
            }

            if (schema.TryGetProperty("maximum", out var maximum) &&
                num > maximum.GetDouble())
            {
                errors.Add($"{path}: Value {num} > maximum {maximum.GetDouble()}");
            }
        }
    }

    private static bool IsTypeMatch(JsonElement element, string? expectedType)
    {
        return expectedType switch
        {
            "object" => element.ValueKind == JsonValueKind.Object,
            "array" => element.ValueKind == JsonValueKind.Array,
            "string" => element.ValueKind == JsonValueKind.String,
            "number" => element.ValueKind == JsonValueKind.Number,
            "integer" => element.ValueKind == JsonValueKind.Number && element.TryGetInt32(out _),
            "boolean" => element.ValueKind == JsonValueKind.True || element.ValueKind == JsonValueKind.False,
            "null" => element.ValueKind == JsonValueKind.Null,
            _ => true
        };
    }
}

public class ValidationResult
{
    public bool IsValid { get; set; }
    public List<string> Errors { get; set; } = new();

    public override string ToString()
    {
        return IsValid
            ? "Validation successful"
            : $"Validation failed:\n  - {string.Join("\n  - ", Errors)}";
    }
}

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.Infrastructure\DefaultPlanner.cs
------------------------------------------------------------------------------
using System.Text.Json;
using ProjectName.Core.Interfaces;

namespace ProjectName.Infrastructure;

public class DefaultPlanner : IPlanner
{
    public Task<PlanResult> CreatePlanAsync(string intent, CancellationToken ct = default)
    {
        // Simple fallback plan using required init syntax
        var steps = new List<PlanStep>
        {
            new() { Order = 1, Action = "Analyze Input", Tool = "manual_intervention", ArgumentsJson = "{}" },
            new() { Order = 2, Action = "Reflect", Tool = "manual_intervention", ArgumentsJson = "{}" }
        };

        var result = new PlanResult
        {
            Goal = intent,
            Steps = steps,
            Analysis = "Default planner execution"
        };

        return Task.FromResult(result);
    }

    public Task<string> ValidateOutcomeAsync(string intent, string executionLog, CancellationToken ct = default)
    {
        // Default validation always passes
        var validation = new
        {
            success = true,
            reasoning = "Default planner assumes success without AI validation.",
            correction = (string?)null
        };

        return Task.FromResult(JsonSerializer.Serialize(validation));
    }
}

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.Infrastructure\ProjectName.Infrastructure.csproj
------------------------------------------------------------------------------
<Project Sdk="Microsoft.NET.Sdk">
	<PropertyGroup>
		<TargetFramework>net10.0</TargetFramework>
		<ImplicitUsings>enable</ImplicitUsings>
		<Nullable>enable</Nullable>
		<NoWarn>$(NoWarn);NU1507;NU1605</NoWarn>
	</PropertyGroup>
	<PropertyGroup>
		<AgentRole>DEFAULT_AGENT_ROLE</AgentRole>
		<AgentExpertise>DEFAULT_AGENT_EXPERTISE</AgentExpertise>
		<AgentVoice>DEFAULT_AGENT_VOICE</AgentVoice>
	</PropertyGroup>
	<ItemGroup>
		<AssemblyAttribute Include="ProjectName.Core.Attributes.AgentPersonaAttribute">
			<_Parameter1>$(AgentRole)</_Parameter1>
			<_Parameter2>$(AgentExpertise)</_Parameter2>
			<_Parameter3>$(AgentVoice)</_Parameter3>
		</AssemblyAttribute>
	</ItemGroup>
	<ItemGroup>
		<!-- Microsoft.Extensions.AI for IChatClient abstraction -->
		<PackageReference Include="Microsoft.Extensions.AI" />

		<!-- Database -->
		<PackageReference Include="Microsoft.EntityFrameworkCore" />
		<PackageReference Include="Microsoft.EntityFrameworkCore.Tools" PrivateAssets="all" />
		<PackageReference Include="Npgsql.EntityFrameworkCore.PostgreSQL" />

		<!-- MCP Protocol -->
		<PackageReference Include="ModelContextProtocol" />
		<PackageReference Include="ModelContextProtocol.Core" />

		<!-- Extensions -->
		<PackageReference Include="Microsoft.Extensions.Http" />
		<PackageReference Include="Microsoft.Extensions.Configuration" />
		<PackageReference Include="Microsoft.Extensions.Configuration.Binder" />
		<PackageReference Include="Microsoft.Extensions.Logging.Abstractions" />
	</ItemGroup>
	<ItemGroup>
		<ProjectReference Include="..\ProjectName.Core\ProjectName.Core.csproj" />
	</ItemGroup>
</Project>

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.McpServer\Properties\launchSettings.json
------------------------------------------------------------------------------
{
  "$schema": "https://json.schemastore.org/launchsettings.json",
  "profiles": {
    "http": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "http://localhost:5159",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "https": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "https://localhost:7034;http://localhost:5159",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}


------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.McpServer\Services\McpServerService.cs
------------------------------------------------------------------------------
using ProjectName.McpServer.Tools;
using System.Text.Json;

namespace ProjectName.McpServer.Services;

/// <summary>
/// MCP Server implementation handling protocol messages and tool routing
/// </summary>
public class McpServerService
{
    private readonly ILogger<McpServerService> _logger;
    private readonly IServiceProvider _serviceProvider;
    private readonly Dictionary<string, Type> _tools;
    private static readonly JsonSerializerOptions JsonOptions = new()
    {
        WriteIndented = true
    };

    public McpServerService(
        ILogger<McpServerService> logger,
        IServiceProvider serviceProvider)
    {
        _logger = logger;
        _serviceProvider = serviceProvider;
        _tools = [];

        RegisterTools();
    }

    private void RegisterTools()
    {
        // Register all browser tools
        RegisterTool<BrowserNavigateTool>();
        RegisterTool<BrowserClickTool>();
        RegisterTool<BrowserTypeTool>();
        RegisterTool<BrowserScreenshotTool>();
        RegisterTool<BrowserExtractTool>();
        RegisterTool<BrowserEvaluateTool>();

        _logger.LogInformation("Registered {Count} MCP tools", _tools.Count);
    }

    private void RegisterTool<TTool>() where TTool : class
    {
        var toolInstance = _serviceProvider.GetRequiredService<TTool>();
        var nameProperty = typeof(TTool).GetProperty("Name");

        if (nameProperty != null)
        {
            var name = nameProperty.GetValue(toolInstance) as string;
            if (!string.IsNullOrEmpty(name))
            {
                _tools[name] = typeof(TTool);
                _logger.LogDebug("Registered tool: {ToolName}", name);
            }
        }
    }

    /// <summary>
    /// Handle incoming MCP request
    /// </summary>
    public async Task<McpResponse> HandleRequestAsync(McpRequest request, CancellationToken ct = default)
    {
        if (_logger.IsEnabled(LogLevel.Information))
        {
            _logger.LogInformation("Handling MCP request: {Method}", request.Method);
        }

        try
        {
            return request.Method switch
            {
                "initialize" => HandleInitialize(request),
                "tools/list" => await HandleListToolsAsync(ct),
                "tools/call" => await HandleToolCallAsync(request, ct),
                _ => McpResponse.CreateError(request.Id, -32601, $"Method not found: {request.Method}")
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error handling MCP request");
            return McpResponse.CreateError(request.Id, -32603, ex.Message);
        }
    }

    private static McpResponse HandleInitialize(McpRequest request)
    {
        var result = new
        {
            protocolVersion = "2024-11-05",
            serverInfo = new
            {
                name = "pmcro-mcp-server",
                version = "1.0.0"
            },
            capabilities = new
            {
                tools = new { }
            }
        };

        return McpResponse.CreateSuccess(request.Id, result);
    }

    private async Task<McpResponse> HandleListToolsAsync(CancellationToken ct)
    {
        var tools = new List<object>();

        foreach (var (name, toolType) in _tools)
        {
            var toolInstance = _serviceProvider.GetRequiredService(toolType);

            var nameProperty = toolType.GetProperty("Name");
            var descProperty = toolType.GetProperty("Description");
            var schemaProperty = toolType.GetProperty("InputSchema");

            var toolInfo = new
            {
                name = nameProperty?.GetValue(toolInstance) as string ?? name,
                description = descProperty?.GetValue(toolInstance) as string ?? "",
                inputSchema = schemaProperty?.GetValue(toolInstance) ?? new { }
            };

            tools.Add(toolInfo);
        }

        var result = new { tools };
        return McpResponse.CreateSuccess(null, result);
    }

    private async Task<McpResponse> HandleToolCallAsync(McpRequest request, CancellationToken ct)
    {
        if (request.Params == null)
        {
            return McpResponse.CreateError(request.Id, -32602, "Missing params");
        }

        var paramsElement = (JsonElement)request.Params;

        if (!paramsElement.TryGetProperty("name", out var nameElement))
        {
            return McpResponse.CreateError(request.Id, -32602, "Missing tool name");
        }

        var toolName = nameElement.GetString();

        if (string.IsNullOrEmpty(toolName) || !_tools.TryGetValue(toolName, out var toolType))
        {
            return McpResponse.CreateError(request.Id, -32602, $"Unknown tool: {toolName}");
        }

        var arguments = paramsElement.TryGetProperty("arguments", out var argsElement)
            ? argsElement
            : JsonDocument.Parse("{}").RootElement;

        // Get tool instance
        var tool = _serviceProvider.GetRequiredService(toolType);

        // Find ExecuteAsync method that takes JsonElement
        var executeMethod = toolType.GetMethod("ExecuteAsync", [typeof(JsonElement), typeof(CancellationToken)]);

        if (executeMethod == null)
        {
            return McpResponse.CreateError(request.Id, -32603, "Tool execution method not found");
        }

        // Invoke tool
        var task = executeMethod.Invoke(tool, [arguments, ct]) as Task<McpToolResult>;
        var result = await task!;

        if (!result.IsSuccess)
        {
            return McpResponse.CreateError(request.Id, -32603, result.Error ?? "Tool execution failed");
        }

        var response = new
        {
            content = new[]
            {
                new
                {
                    type = "text",
                    text = JsonSerializer.Serialize(result.Content, JsonOptions)
                }
            }
        };

        return McpResponse.CreateSuccess(request.Id, response);
    }
}

/// <summary>
/// MCP request message
/// </summary>
public record McpRequest(
    string Method,
    string? Id = null,
    object? Params = null)
{
    public string JsonRpc { get; init; } = "2.0";
}

/// <summary>
/// MCP response message
/// </summary>
public record McpResponse(
    string? Id,
    object? Result = null,
    McpError? ErrorInfo = null)
{
    public string JsonRpc { get; init; } = "2.0";

    public static McpResponse CreateSuccess(string? id, object result)
    {
        return new McpResponse(
            Id: id,
            Result: result,
            ErrorInfo: null
        );
    }

    public static McpResponse CreateError(string? id, int code, string message)
    {
        return new McpResponse(
            Id: id,
            Result: null,
            ErrorInfo: new McpError(code, message)
        );
    }
}

/// <summary>
/// MCP error details
/// </summary>
public record McpError(int Code, string Message);

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.McpServer\Services\PlaywrightManager.cs
------------------------------------------------------------------------------
using Microsoft.Playwright;

namespace ProjectName.McpServer.Services;

/// <summary>
/// Manages Playwright browser lifecycle and page instances
/// Implements singleton pattern for browser reuse across tool calls
/// </summary>
public class PlaywrightManager : IAsyncDisposable
{
    private readonly ILogger<PlaywrightManager> _logger;
    private readonly SemaphoreSlim _initLock = new(1, 1);

    private IPlaywright? _playwright;
    private IBrowser? _browser;
    private IPage? _currentPage;
    private bool _isInitialized;

    public PlaywrightManager(ILogger<PlaywrightManager> logger)
    {
        _logger = logger;
    }

    /// <summary>
    /// Initialize Playwright and launch browser
    /// Thread-safe, idempotent
    /// </summary>
    public async Task InitializeAsync()
    {
        if (_isInitialized)
            return;

        await _initLock.WaitAsync();
        try
        {
            if (_isInitialized)
                return;

            _logger.LogInformation("Initializing Playwright...");

            // Install Playwright browsers if not already installed
            var exitCode = Microsoft.Playwright.Program.Main(new[] { "install", "chromium" });
            if (exitCode != 0)
            {
                _logger.LogWarning("Playwright install returned exit code: {ExitCode}", exitCode);
            }

            _playwright = await Playwright.CreateAsync();

            _browser = await _playwright.Chromium.LaunchAsync(new BrowserTypeLaunchOptions
            {
                Headless = true,
                Args = new[]
                {
                    "--disable-blink-features=AutomationControlled",
                    "--disable-dev-shm-usage",
                    "--no-sandbox"
                }
            });

            _logger.LogInformation("Playwright browser launched successfully");
            _isInitialized = true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to initialize Playwright");
            throw;
        }
        finally
        {
            _initLock.Release();
        }
    }

    /// <summary>
    /// Get or create the current page instance
    /// </summary>
    public async Task<IPage> GetPageAsync()
    {
        if (!_isInitialized)
        {
            await InitializeAsync();
        }

        if (_currentPage == null || _currentPage.IsClosed)
        {
            if (_browser == null)
            {
                throw new InvalidOperationException("Browser not initialized");
            }

            var context = await _browser.NewContextAsync(new BrowserNewContextOptions
            {
                ViewportSize = new ViewportSize { Width = 1920, Height = 1080 },
                UserAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
            });

            _currentPage = await context.NewPageAsync();

            _logger.LogInformation("New browser page created");
        }

        return _currentPage;
    }

    /// <summary>
    /// Close current page and create new one
    /// </summary>
    public async Task ResetPageAsync()
    {
        if (_currentPage != null && !_currentPage.IsClosed)
        {
            await _currentPage.CloseAsync();
            _currentPage = null;
        }

        _logger.LogInformation("Browser page reset");
    }

    /// <summary>
    /// Get browser instance (for advanced scenarios)
    /// </summary>
    public IBrowser? Browser => _browser;

    public async ValueTask DisposeAsync()
    {
        _logger.LogInformation("Disposing Playwright resources...");

        if (_currentPage != null && !_currentPage.IsClosed)
        {
            await _currentPage.CloseAsync();
        }

        if (_browser != null)
        {
            await _browser.CloseAsync();
            await _browser.DisposeAsync();
        }

        _playwright?.Dispose();
        _initLock.Dispose();

        _logger.LogInformation("Playwright resources disposed");
    }
}

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.McpServer\Tools\BrowserClickTool.cs
------------------------------------------------------------------------------
using ProjectName.McpServer.Services;

namespace ProjectName.McpServer.Tools;

/// <summary>
/// Click an element on the page
/// </summary>
public class BrowserClickTool(
    PlaywrightManager playwright,
    ILogger<BrowserClickTool> logger) : McpToolBase<BrowserClickInput, BrowserClickOutput>(logger)
{
    private readonly PlaywrightManager _playwright = playwright;

    public override string Name => "browser_click";

    public override string Description => "Click an element on the page using a CSS selector";

    public override async Task<BrowserClickOutput> ExecuteAsync(
        BrowserClickInput input,
        CancellationToken ct = default)
    {
        if (Logger.IsEnabled(LogLevel.Information))
        {
            Logger.LogInformation("Clicking element: {Selector}", input.Selector);
        }

        var page = await _playwright.GetPageAsync();

        await page.ClickAsync(input.Selector, new()
        {
            Button = input.Button switch
            {
                "right" => Microsoft.Playwright.MouseButton.Right,
                "middle" => Microsoft.Playwright.MouseButton.Middle,
                _ => Microsoft.Playwright.MouseButton.Left
            },
            ClickCount = input.ClickCount ?? 1,
            Delay = input.Delay,
            Timeout = input.Timeout ?? 30000
        });

        Logger.LogInformation("Clicked element successfully");

        return new BrowserClickOutput
        {
            Success = true,
            Selector = input.Selector
        };
    }
}

public record BrowserClickInput
{
    public string Selector { get; init; } = "";
    public string? Button { get; init; } = "left"; // left, right, middle
    public int? ClickCount { get; init; } = 1;
    public float? Delay { get; init; }
    public int? Timeout { get; init; } = 30000;
}

public record BrowserClickOutput
{
    public bool Success { get; init; }
    public string Selector { get; init; } = "";
}

/// <summary>
/// Type text into an input element
/// </summary>
public class BrowserTypeTool(
    PlaywrightManager playwright,
    ILogger<BrowserTypeTool> logger) : McpToolBase<BrowserTypeInput, BrowserTypeOutput>(logger)
{
    private readonly PlaywrightManager _playwright = playwright;

    public override string Name => "browser_type";

    public override string Description => "Type text into an input field";

    public override async Task<BrowserTypeOutput> ExecuteAsync(
        BrowserTypeInput input,
        CancellationToken ct = default)
    {
        if (Logger.IsEnabled(LogLevel.Information))
        {
            Logger.LogInformation("Typing into element: {Selector}", input.Selector);
        }

        var page = await _playwright.GetPageAsync();

        if (input.Clear)
        {
            await page.FillAsync(input.Selector, "");
        }

        // Use FillAsync instead of deprecated TypeAsync
        await page.FillAsync(input.Selector, input.Text);

        if (Logger.IsEnabled(LogLevel.Information))
        {
            Logger.LogInformation("Typed {Length} characters successfully", input.Text.Length);
        }

        return new BrowserTypeOutput
        {
            Success = true,
            Selector = input.Selector,
            CharactersTyped = input.Text.Length
        };
    }
}

public record BrowserTypeInput
{
    public string Selector { get; init; } = "";
    public string Text { get; init; } = "";
    public bool Clear { get; init; } = false;
    public float? Delay { get; init; } = 50; // Delay between keystrokes in ms
    public int? Timeout { get; init; } = 30000;
}

public record BrowserTypeOutput
{
    public bool Success { get; init; }
    public string Selector { get; init; } = "";
    public int CharactersTyped { get; init; }
}

/// <summary>
/// Evaluate JavaScript in the browser context
/// </summary>
public class BrowserEvaluateTool(
    PlaywrightManager playwright,
    ILogger<BrowserEvaluateTool> logger) : McpToolBase<BrowserEvaluateInput, BrowserEvaluateOutput>(logger)
{
    private readonly PlaywrightManager _playwright = playwright;

    public override string Name => "browser_evaluate";

    public override string Description => "Execute JavaScript code in the browser context";

    public override async Task<BrowserEvaluateOutput> ExecuteAsync(
        BrowserEvaluateInput input,
        CancellationToken ct = default)
    {
        Logger.LogInformation("Evaluating JavaScript in browser");

        var page = await _playwright.GetPageAsync();

        var result = await page.EvaluateAsync<object>(input.Script);

        Logger.LogInformation("JavaScript evaluation completed");

        return new BrowserEvaluateOutput
        {
            Success = true,
            Result = result
        };
    }
}

public record BrowserEvaluateInput
{
    public string Script { get; init; } = "";
}

public record BrowserEvaluateOutput
{
    public bool Success { get; init; }
    public object? Result { get; init; }
}

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.McpServer\Tools\BrowserExtractTool.cs
------------------------------------------------------------------------------
using ProjectName.McpServer.Services;

namespace ProjectName.McpServer.Tools;

/// <summary>
/// Extract structured data from the current browser page
/// </summary>
public class BrowserExtractTool : McpToolBase<BrowserExtractInput, BrowserExtractOutput>
{
    private readonly PlaywrightManager _playwright;

    public BrowserExtractTool(
        PlaywrightManager playwright,
        ILogger<BrowserExtractTool> logger) : base(logger)
    {
        _playwright = playwright;
    }

    public override string Name => "browser_extract";

    public override string Description => "Extract text, HTML, or structured data from elements on the page";

    public override async Task<BrowserExtractOutput> ExecuteAsync(
        BrowserExtractInput input,
        CancellationToken ct = default)
    {
        Logger.LogInformation("Extracting data with selector: {Selector}", input.Selector);

        var page = await _playwright.GetPageAsync();

        var results = new List<object>();

        if (input.ExtractAll)
        {
            var elements = await page.QuerySelectorAllAsync(input.Selector);

            foreach (var element in elements)
            {
                var data = await ExtractFromElementAsync(element, input.Format);
                results.Add(data);
            }
        }
        else
        {
            var element = await page.QuerySelectorAsync(input.Selector);

            if (element != null)
            {
                var data = await ExtractFromElementAsync(element, input.Format);
                results.Add(data);
            }
        }

        Logger.LogInformation("Extracted {Count} elements", results.Count);

        return new BrowserExtractOutput
        {
            Success = results.Count > 0,
            Data = results,
            Count = results.Count
        };
    }

    private async Task<object> ExtractFromElementAsync(
        Microsoft.Playwright.IElementHandle element,
        string format)
    {
        return format.ToLowerInvariant() switch
        {
            "text" => await element.TextContentAsync() ?? "",
            "html" => await element.InnerHTMLAsync(),
            "innertext" => await element.InnerTextAsync(),
            "attributes" => await ExtractAttributesAsync(element),
            _ => await element.TextContentAsync() ?? ""
        };
    }

    private async Task<Dictionary<string, string>> ExtractAttributesAsync(
        Microsoft.Playwright.IElementHandle element)
    {
        var attributes = new Dictionary<string, string>();

        // Common attributes to extract
        var attrNames = new[] { "id", "class", "href", "src", "alt", "title", "data-*" };

        foreach (var attr in attrNames)
        {
            var value = await element.GetAttributeAsync(attr);
            if (!string.IsNullOrEmpty(value))
            {
                attributes[attr] = value;
            }
        }

        return attributes;
    }
}

public record BrowserExtractInput
{
    public string Selector { get; init; } = "";
    public string Format { get; init; } = "text"; // text, html, innertext, attributes
    public bool ExtractAll { get; init; } = false;
}

public record BrowserExtractOutput
{
    public bool Success { get; init; }
    public List<object> Data { get; init; } = new();
    public int Count { get; init; }
}

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.McpServer\Tools\BrowserNavigateTool.cs
------------------------------------------------------------------------------
using ProjectName.McpServer.Services;

namespace ProjectName.McpServer.Tools;

/// <summary>
/// Navigate to a URL in the browser
/// </summary>
public class BrowserNavigateTool : McpToolBase<BrowserNavigateInput, BrowserNavigateOutput>
{
    private readonly PlaywrightManager _playwright;

    public BrowserNavigateTool(
        PlaywrightManager playwright,
        ILogger<BrowserNavigateTool> logger) : base(logger)
    {
        _playwright = playwright;
    }

    public override string Name => "browser_navigate";

    public override string Description => "Navigate to a URL in the headless browser";

    public override async Task<BrowserNavigateOutput> ExecuteAsync(
        BrowserNavigateInput input,
        CancellationToken ct = default)
    {
        Logger.LogInformation("Navigating to: {Url}", input.Url);

        var page = await _playwright.GetPageAsync();

        var response = await page.GotoAsync(input.Url, new()
        {
            WaitUntil = input.WaitUntil switch
            {
                "networkidle" => Microsoft.Playwright.WaitUntilState.NetworkIdle,
                "domcontentloaded" => Microsoft.Playwright.WaitUntilState.DOMContentLoaded,
                _ => Microsoft.Playwright.WaitUntilState.Load
            },
            Timeout = input.Timeout ?? 30000
        });

        var title = await page.TitleAsync();
        var url = page.Url;

        Logger.LogInformation("Navigated successfully - Title: {Title}", title);

        return new BrowserNavigateOutput
        {
            Success = response?.Ok ?? false,
            Url = url,
            Title = title,
            StatusCode = response?.Status ?? 0
        };
    }
}

public record BrowserNavigateInput
{
    public string Url { get; init; } = "";
    public string? WaitUntil { get; init; } = "load";
    public int? Timeout { get; init; } = 30000;
}

public record BrowserNavigateOutput
{
    public bool Success { get; init; }
    public string Url { get; init; } = "";
    public string Title { get; init; } = "";
    public int StatusCode { get; init; }
}

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.McpServer\Tools\BrowserScreenshotTool.cs
------------------------------------------------------------------------------
using ProjectName.McpServer.Services;

namespace ProjectName.McpServer.Tools;

/// <summary>
/// Capture screenshots of the current page or specific elements
/// </summary>
public class BrowserScreenshotTool : McpToolBase<BrowserScreenshotInput, BrowserScreenshotOutput>
{
    private readonly PlaywrightManager _playwright;
    private readonly IConfiguration _config;

    public BrowserScreenshotTool(
        PlaywrightManager playwright,
        IConfiguration config,
        ILogger<BrowserScreenshotTool> logger) : base(logger)
    {
        _playwright = playwright;
        _config = config;
    }

    public override string Name => "browser_screenshot";

    public override string Description => "Capture a screenshot of the current page or a specific element";

    public override async Task<BrowserScreenshotOutput> ExecuteAsync(
        BrowserScreenshotInput input,
        CancellationToken ct = default)
    {
        Logger.LogInformation("Capturing screenshot: {Path}", input.Path ?? "base64");

        var page = await _playwright.GetPageAsync();

        byte[] screenshot;

        if (!string.IsNullOrEmpty(input.Selector))
        {
            // Screenshot of specific element
            var element = await page.QuerySelectorAsync(input.Selector);
            if (element == null)
            {
                throw new InvalidOperationException($"Element not found: {input.Selector}");
            }

            screenshot = await element.ScreenshotAsync(new()
            {
                Type = input.Format == "png" ? Microsoft.Playwright.ScreenshotType.Png : Microsoft.Playwright.ScreenshotType.Jpeg,
                Quality = input.Quality
            });
        }
        else
        {
            // Full page screenshot
            screenshot = await page.ScreenshotAsync(new()
            {
                FullPage = input.FullPage,
                Type = input.Format == "png" ? Microsoft.Playwright.ScreenshotType.Png : Microsoft.Playwright.ScreenshotType.Jpeg,
                Quality = input.Quality
            });
        }

        string? filePath = null;
        string? base64Data = null;

        if (!string.IsNullOrEmpty(input.Path))
        {
            // Save to file
            var screenshotsDir = _config["McpSettings:ScreenshotsDirectory"] ?? "./screenshots";
            Directory.CreateDirectory(screenshotsDir);

            filePath = Path.Combine(screenshotsDir, input.Path);
            await File.WriteAllBytesAsync(filePath, screenshot, ct);

            Logger.LogInformation("Screenshot saved to: {Path}", filePath);
        }
        else
        {
            // Return as base64
            base64Data = Convert.ToBase64String(screenshot);
        }

        return new BrowserScreenshotOutput
        {
            Success = true,
            Path = filePath,
            Base64 = base64Data,
            Size = screenshot.Length
        };
    }
}

public record BrowserScreenshotInput
{
    public string? Path { get; init; }
    public string? Selector { get; init; }
    public bool FullPage { get; init; } = false;
    public string Format { get; init; } = "png"; // png or jpeg
    public int? Quality { get; init; } = 90; // JPEG quality 0-100
}

public record BrowserScreenshotOutput
{
    public bool Success { get; init; }
    public string? Path { get; init; }
    public string? Base64 { get; init; }
    public int Size { get; init; }
}

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.McpServer\Tools\McpToolBase.cs
------------------------------------------------------------------------------
using System.Text.Json;

namespace ProjectName.McpServer.Tools;

/// <summary>
/// Base class for all MCP tools with structured input/output
/// Provides JSON schema generation and execution framework
/// </summary>
public abstract class McpToolBase<TInput, TOutput>
{
    protected ILogger Logger { get; }

    protected McpToolBase(ILogger logger)
    {
        Logger = logger;
    }

    /// <summary>
    /// Tool identifier (e.g., "browser_navigate")
    /// </summary>
    public abstract string Name { get; }

    /// <summary>
    /// Human-readable description of what this tool does
    /// </summary>
    public abstract string Description { get; }

    /// <summary>
    /// JSON schema for input validation
    /// </summary>
    public virtual object InputSchema => GenerateInputSchema();

    /// <summary>
    /// Execute the tool with typed input
    /// </summary>
    public abstract Task<TOutput> ExecuteAsync(TInput input, CancellationToken ct = default);

    /// <summary>
    /// Execute the tool with raw JSON input (MCP protocol)
    /// </summary>
    public async Task<McpToolResult> ExecuteAsync(JsonElement arguments, CancellationToken ct = default)
    {
        try
        {
            // Deserialize to typed input
            var input = JsonSerializer.Deserialize<TInput>(arguments.GetRawText(), new JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true
            });

            if (input == null)
            {
                return McpToolResult.Failure(Name, "Failed to deserialize input arguments");
            }

            // Execute
            var output = await ExecuteAsync(input, ct);

            // Serialize result
            return McpToolResult.Success(Name, output);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Tool execution failed: {Tool}", Name);
            return McpToolResult.Failure(Name, ex.Message);
        }
    }

    /// <summary>
    /// Generate JSON schema from TInput type
    /// </summary>
    protected virtual object GenerateInputSchema()
    {
        var type = typeof(TInput);
        var properties = new Dictionary<string, object>();
        var required = new List<string>();

        foreach (var prop in type.GetProperties())
        {
            var propName = char.ToLowerInvariant(prop.Name[0]) + prop.Name[1..];

            properties[propName] = new
            {
                type = GetJsonType(prop.PropertyType),
                description = GetPropertyDescription(prop)
            };

            // Required if not nullable
            if (!IsNullable(prop.PropertyType))
            {
                required.Add(propName);
            }
        }

        return new
        {
            type = "object",
            properties,
            required = required.Count > 0 ? required : null
        };
    }

    private static string GetJsonType(Type type)
    {
        var underlyingType = Nullable.GetUnderlyingType(type) ?? type;

        if (underlyingType == typeof(string))
            return "string";
        if (underlyingType == typeof(int) || underlyingType == typeof(long))
            return "integer";
        if (underlyingType == typeof(bool))
            return "boolean";
        if (underlyingType == typeof(double) || underlyingType == typeof(float) || underlyingType == typeof(decimal))
            return "number";
        if (underlyingType.IsArray || typeof(System.Collections.IEnumerable).IsAssignableFrom(underlyingType))
            return "array";

        return "object";
    }

    private static bool IsNullable(Type type)
    {
        return !type.IsValueType || Nullable.GetUnderlyingType(type) != null;
    }

    private static string GetPropertyDescription(System.Reflection.PropertyInfo prop)
    {
        // Try to get description from XML comments or attributes
        // For now, return a default description
        return $"{prop.Name} parameter";
    }
}

/// <summary>
/// MCP tool execution result
/// </summary>
public record McpToolResult
{
    public bool IsSuccess { get; init; }
    public string ToolName { get; init; } = "";
    public object? Content { get; init; }
    public string? Error { get; init; }

    public static McpToolResult Success(string toolName, object content)
    {
        return new McpToolResult
        {
            IsSuccess = true,
            ToolName = toolName,
            Content = content,
            Error = null
        };
    }

    public static McpToolResult Failure(string toolName, string error)
    {
        return new McpToolResult
        {
            IsSuccess = false,
            ToolName = toolName,
            Content = null,
            Error = error
        };
    }
}

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.McpServer\appsettings.Development.json
------------------------------------------------------------------------------
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}


------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.McpServer\appsettings.json
------------------------------------------------------------------------------
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "ProjectName.McpServer": "Debug"
    }
  },
  "AllowedHosts": "*",

  "McpSettings": {
    "ServerName": "pmcro-mcp-server",
    "Version": "1.0.0",
    "ScreenshotsDirectory": "./screenshots",
    "Browser": {
      "Headless": true,
      "DefaultTimeout": 30000,
      "ViewportWidth": 1920,
      "ViewportHeight": 1080
    }
  }
}

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.McpServer\Program.cs
------------------------------------------------------------------------------
using Microsoft.OpenApi;
using ProjectName.McpServer.Services;
using ProjectName.McpServer.Tools;
using ProjectName.ServiceDefaults;
using System.Text.Json;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen(options =>
{
    options.SwaggerDoc("v1", new OpenApiInfo
    {
        Title = "PMCR-O MCP Server",
        Version = "v1",
        Description = "Model Context Protocol server for browser automation and tool execution"
    });
});

// Register PlaywrightManager as singleton (browser lifecycle)
builder.Services.AddSingleton<PlaywrightManager>();
// ... previous code ...

// Register MCP Server Service (Keep as Singleton)
builder.Services.AddSingleton<McpServerService>();

// Register all MCP tools as SINGLETONS (Not Scoped)
// They depend on PlaywrightManager (Singleton) and ILogger (Singleton), so this is safe.
builder.Services.AddSingleton<BrowserNavigateTool>();
builder.Services.AddSingleton<BrowserClickTool>();
builder.Services.AddSingleton<BrowserTypeTool>();
builder.Services.AddSingleton<BrowserScreenshotTool>();
builder.Services.AddSingleton<BrowserExtractTool>();
builder.Services.AddSingleton<BrowserEvaluateTool>();

// Add Aspire service defaults
// ... rest of code ...

// Add Aspire service defaults (telemetry, health checks)
builder.AddServiceDefaults();

var app = builder.Build();

// Initialize Playwright on startup
var playwright = app.Services.GetRequiredService<PlaywrightManager>();
await playwright.InitializeAsync();

// Cached JSON options
var jsonOptions = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };

// Configure the HTTP request pipeline
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI(options =>
    {
        options.SwaggerEndpoint("/swagger/v1/swagger.json", "MCP Server API v1");
    });
}

app.UseHttpsRedirection();

// MCP Protocol Endpoint
app.MapPost("/mcp", async (
    HttpContext context,
    McpServerService mcpServer) =>
{
    try
    {
        // Read request
        var request = await JsonSerializer.DeserializeAsync<McpRequest>(
            context.Request.Body,
            jsonOptions);

        if (request == null)
        {
            context.Response.StatusCode = 400;
            await context.Response.WriteAsJsonAsync(new { error = "Invalid request" });
            return;
        }

        // Handle request
        var response = await mcpServer.HandleRequestAsync(request, context.RequestAborted);

        // Write response
        await context.Response.WriteAsJsonAsync(response);
    }
    catch (Exception ex)
    {
        context.Response.StatusCode = 500;
        await context.Response.WriteAsJsonAsync(new
        {
            jsonrpc = "2.0",
            error = new
            {
                code = -32603,
                message = ex.Message
            }
        });
    }
})
.WithName("McpProtocol");

// Health check endpoint
app.MapGet("/health", (PlaywrightManager playwright) =>
{
    var isHealthy = playwright.Browser != null && playwright.Browser.IsConnected;

    return Results.Json(new
    {
        status = isHealthy ? "healthy" : "unhealthy",
        browser = isHealthy ? "connected" : "disconnected",
        timestamp = DateTime.UtcNow
    });
})
.WithName("HealthCheck");

// List available tools endpoint (for debugging)
app.MapGet("/tools", async (McpServerService mcpServer) =>
{
    var request = new McpRequest("tools/list");
    var response = await mcpServer.HandleRequestAsync(request);
    return Results.Json(response.Result);
})
.WithName("ListTools");

// Map default Aspire endpoints
app.MapDefaultEndpoints();

app.Run();

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.McpServer\ProjectName.McpServer.csproj
------------------------------------------------------------------------------
<Project Sdk="Microsoft.NET.Sdk.Web">

	<PropertyGroup>
		<TargetFramework>net10.0</TargetFramework>
		<Nullable>enable</Nullable>
		<ImplicitUsings>enable</ImplicitUsings>
		<UserSecretsId>mcp-server-$(MSBuildProjectName)</UserSecretsId>
	</PropertyGroup>

	<ItemGroup>
		<!-- MCP Protocol Support -->
		<PackageReference Include="ModelContextProtocol" />
		<PackageReference Include="ModelContextProtocol.Core" />

		<!-- Playwright for Browser Automation -->
		<PackageReference Include="Microsoft.Playwright" />

		<!-- ASP.NET Core -->
		<PackageReference Include="Microsoft.AspNetCore.OpenApi" />
		<PackageReference Include="Swashbuckle.AspNetCore" />
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\ProjectName.Core\ProjectName.Core.csproj" />
		<ProjectReference Include="..\ProjectName.Infrastructure\ProjectName.Infrastructure.csproj" />
		<ProjectReference Include="..\ProjectName.ServiceDefaults\ProjectName.ServiceDefaults.csproj" />
	</ItemGroup>

</Project>

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.OrchestrationApi\Controllers\OrchestrationController.cs
------------------------------------------------------------------------------
using Microsoft.AspNetCore.Mvc;
using ProjectName.Application;
using System.ComponentModel.DataAnnotations;

namespace ProjectName.OrchestrationApi.Controllers;

/// <summary>
/// REST API Gateway for PMCR-O Orchestration
/// Acts as the Nervous System trigger, invoking the Cognitive Orchestrator
/// to execute the full Plan-Make-Check-Reflect loop.
/// </summary>
[ApiController]
[Route("api/[controller]")]
public class OrchestrationController : ControllerBase
{
    private readonly CognitiveOrchestrator _orchestrator;
    private readonly ILogger<OrchestrationController> _logger;

    public OrchestrationController(
        CognitiveOrchestrator orchestrator,
        ILogger<OrchestrationController> logger)
    {
        _orchestrator = orchestrator;
        _logger = logger;
    }

    /// <summary>
    /// Executes a full PMCR-O cognitive cycle based on user intent.
    /// 1. PLANS using the Planner Service (Brain/LLM).
    /// 2. MAKES using the MCP Server (Body/Tools).
    /// 3. RECORDS the cognitive trail.
    /// </summary>
    /// <param name="request">The seed intent (e.g., "Navigate to google.com...")</param>
    /// <returns>A JSON report containing the Goal, Status, and Execution Log.</returns>
    [HttpPost("execute")]
    [ProducesResponseType(StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    [ProducesResponseType(StatusCodes.Status500InternalServerError)]
    public async Task<IActionResult> ExecuteIntent(
        [FromBody] CreatePlanRequest request,
        CancellationToken ct)
    {
        if (!ModelState.IsValid)
        {
            return BadRequest(ModelState);
        }

        _logger.LogInformation("Received execution request: {Intent}", request.Intent);

        try
        {
            // Triggers the Full PMCR-O Loop (Plan -> Make -> Check -> Reflect)
            // The Orchestrator handles the distributed coordination between gRPC Planner and HTTP MCP.
            var resultJson = await _orchestrator.ProcessIntent(request.Intent, ct);

            // Return raw JSON because the Orchestrator returns a serialized string 
            // containing dynamic tool outputs.
            return Content(resultJson, "application/json");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Orchestration failure");
            return StatusCode(500, new { Error = ex.Message, StackTrace = ex.StackTrace });
        }
    }

    /// <summary>
    /// Simple health check to verify API availability.
    /// </summary>
    [HttpGet("health")]
    public IActionResult HealthCheck()
    {
        return Ok(new { Status = "Healthy", Timestamp = DateTime.UtcNow });
    }
}

// DTOs for REST API

public class CreatePlanRequest
{
    [Required]
    [MinLength(1)]
    public string Intent { get; set; } = string.Empty;
}

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.OrchestrationApi\Properties\launchSettings.json
------------------------------------------------------------------------------
{
  "profiles": {
    "http": {
      "commandName": "Project",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "dotnetRunMessages": true,
      "applicationUrl": "http://localhost:5234"
    },
    "https": {
      "commandName": "Project",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "dotnetRunMessages": true,
      "applicationUrl": "https://localhost:7269;http://localhost:5234"
    },
    "Container (Dockerfile)": {
      "commandName": "Docker",
      "launchUrl": "{Scheme}://{ServiceHost}:{ServicePort}",
      "environmentVariables": {
        "ASPNETCORE_HTTPS_PORTS": "8081",
        "ASPNETCORE_HTTP_PORTS": "8080"
      },
      "publishAllPorts": true,
      "useSSL": true
    }
  },
  "$schema": "https://json.schemastore.org/launchsettings.json"
}

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.OrchestrationApi\Services\GrpcPlannerGateway.cs
------------------------------------------------------------------------------
using ProjectName.Core.Interfaces;
using ProjectName.PlannerService;
using System.Numerics;

namespace ProjectName.OrchestrationApi.Services;

public class GrpcPlannerGateway : IPlanner
{
    private readonly Planner.PlannerClient _grpcClient;
    private readonly ILogger<GrpcPlannerGateway> _logger;

    public GrpcPlannerGateway(Planner.PlannerClient grpcClient, ILogger<GrpcPlannerGateway> logger)
    {
        _grpcClient = grpcClient;
        _logger = logger;
    }

    public async Task<PlanResult> CreatePlanAsync(string intent, CancellationToken ct = default)
    {
        _logger.LogInformation("Forwarding plan request to gRPC service...");

        var request = new PlanRequest { Intent = intent };

        var response = await _grpcClient.CreatePlanAsync(request, cancellationToken: ct);

        if (!response.Success)
        {
            throw new Exception($"Planner service failed: {response.ErrorMessage}");
        }

        var steps = response.Steps.Select(s => new PlanStep
        {
            Order = s.Order,
            Action = s.Action,
            Tool = s.Tool,
            ArgumentsJson = s.ArgumentsJson
        }).ToList();

        return new PlanResult
        {
            Goal = response.Goal,
            Steps = steps,
            Analysis = response.Analysis
        };
    }

    public async Task<string> ValidateOutcomeAsync(string intent, string executionLog, CancellationToken ct = default)
    {
        _logger.LogInformation("Forwarding validation request to gRPC service...");

        var request = new ValidationRequest
        {
            Intent = intent,
            ExecutionLog = executionLog
        };

        var response = await _grpcClient.ValidateOutcomeAsync(request, cancellationToken: ct);

        if (!response.Success)
        {
            throw new Exception($"Validation failed: {response.ErrorMessage}");
        }

        return response.ValidationJson;
    }
}

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.OrchestrationApi\appsettings.Development.json
------------------------------------------------------------------------------
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}


------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.OrchestrationApi\appsettings.json
------------------------------------------------------------------------------
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*"
}


------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.OrchestrationApi\Dockerfile
------------------------------------------------------------------------------
# See https://aka.ms/customizecontainer to learn how to customize your debug container and how Visual Studio uses this Dockerfile to build your images for faster debugging.

# This stage is used when running from VS in fast mode (Default for Debug configuration)
FROM mcr.microsoft.com/dotnet/aspnet:10.0 AS base
USER $APP_UID
WORKDIR /app
EXPOSE 8080
EXPOSE 8081


# This stage is used to build the service project
FROM mcr.microsoft.com/dotnet/sdk:10.0 AS build
ARG BUILD_CONFIGURATION=Release
WORKDIR /src
COPY ["Directory.Packages.props", "."]
COPY ["Directory.Build.props", "."]
COPY ["Directory.Build.targets", "."]
COPY ["nuget.config", "."]
COPY ["src/ProjectName.OrchestrationApi/ProjectName.OrchestrationApi.csproj", "src/ProjectName.OrchestrationApi/"]
RUN dotnet restore "./src/ProjectName.OrchestrationApi/ProjectName.OrchestrationApi.csproj"
COPY . .
WORKDIR "/src/src/ProjectName.OrchestrationApi"
RUN dotnet build "./ProjectName.OrchestrationApi.csproj" -c $BUILD_CONFIGURATION -o /app/build

# This stage is used to publish the service project to be copied to the final stage
FROM build AS publish
ARG BUILD_CONFIGURATION=Release
RUN dotnet publish "./ProjectName.OrchestrationApi.csproj" -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false

# This stage is used in production or when running from VS in regular mode (Default when not using the Debug configuration)
FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "ProjectName.OrchestrationApi.dll"]

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.OrchestrationApi\Program.cs
------------------------------------------------------------------------------
using Microsoft.Extensions.AI;
using Microsoft.OpenApi;
using ProjectName.Application;
using ProjectName.Core.Entities;
using ProjectName.Core.Interfaces;
using ProjectName.Infrastructure.Data;
using ProjectName.Infrastructure.MCP;
using ProjectName.Infrastructure.Services;
using ProjectName.OrchestrationApi.Services;
using ProjectName.PlannerService;
using ProjectName.ServiceDefaults;

var builder = WebApplication.CreateBuilder(args);
builder.AddNpgsqlDbContext<CognitiveDbContext>("cognitivedb");

// Add services to the container
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen(options =>
{
    options.SwaggerDoc("v1", new OpenApiInfo
    {
        Title = "PMCR-O Orchestration API",
        Version = "v1"
    });
});

// 1. REGISTER gRPC CLIENT (Connects to PlannerService)
builder.Services.AddGrpcClient<Planner.PlannerClient>(options =>
{
    var plannerUrl = builder.Configuration.GetConnectionString("planner-service")
        ?? "https://localhost:7035";
    options.Address = new Uri(plannerUrl);
})
.ConfigurePrimaryHttpMessageHandler(() =>
{
    var handler = new HttpClientHandler();
    if (builder.Environment.IsDevelopment())
    {
        handler.ServerCertificateCustomValidationCallback =
            HttpClientHandler.DangerousAcceptAnyServerCertificateValidator;
    }
    return handler;
})
.AddStandardResilienceHandler(options =>
{
    // Allow 10 minutes total for AI operations
    options.TotalRequestTimeout.Timeout = TimeSpan.FromMinutes(10);
    options.AttemptTimeout.Timeout = TimeSpan.FromMinutes(10);
    options.CircuitBreaker.SamplingDuration = TimeSpan.FromMinutes(20);
});

// 2. REGISTER MCP CLIENT (Connects to McpServer)
builder.Services.AddMcpClient(builder.Configuration);

// 3. REGISTER CORE DEPENDENCIES
builder.Services.AddScoped<IPlanner, GrpcPlannerGateway>();
builder.Services.AddScoped<ICognitiveTrail, PersistentCognitiveTrail>();

// The "Ego" - Fixed with Voice parameter
builder.Services.AddSingleton(new AgentIdentity(
    Name: "Orchestrator",
    Role: "Executive",
    Philosophy: "PMCR-O",
    Voice: "Analytical"
));

// 4. REGISTER THE ORCHESTRATOR
builder.Services.AddScoped<CognitiveOrchestrator>();

// Add Aspire defaults
builder.AddServiceDefaults();

var app = builder.Build();

// Initialize database
using (var scope = app.Services.CreateScope())
{
    var services = scope.ServiceProvider;
    var logger = services.GetRequiredService<ILogger<Program>>();
    var context = services.GetRequiredService<CognitiveDbContext>();

    try
    {
        logger.LogInformation("ğŸ§  Initializing Cognitive Memory (Database)...");
        await context.Database.EnsureCreatedAsync();
    }
    catch (Npgsql.PostgresException ex) when (ex.SqlState == "42P04")
    {
        logger.LogWarning("âš ï¸ Database race condition detected. Retrying to ensure Schema...");
        await context.Database.EnsureCreatedAsync();
    }
    catch (Exception ex)
    {
        logger.LogError(ex, "âŒ CRITICAL: Database initialization failed.");
        throw;
    }
}

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI(options =>
    {
        options.SwaggerEndpoint("/swagger/v1/swagger.json", "PMCR-O API v1");
        options.RoutePrefix = string.Empty;
    });
    app.UseCors();
}

app.UseHttpsRedirection();
app.UseAuthorization();
app.MapControllers();
app.MapDefaultEndpoints();

app.Run();

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.OrchestrationApi\ProjectName.OrchestrationApi.csproj
------------------------------------------------------------------------------
<Project Sdk="Microsoft.NET.Sdk.Web">

	<PropertyGroup>
		<TargetFramework>net10.0</TargetFramework>
		<Nullable>enable</Nullable>
		<ImplicitUsings>enable</ImplicitUsings>
		<UserSecretsId>3d7bd789-e3a4-4c4d-bc2c-8aae42e708f6</UserSecretsId>
		<DockerDefaultTargetOS>Linux</DockerDefaultTargetOS>
		<DockerfileContext>..\..</DockerfileContext>
	</PropertyGroup>

	<ItemGroup>
		<Protobuf Include="..\ProjectName.PlannerService\Protos\planner.proto" GrpcServices="Client" />
	</ItemGroup>

	<ItemGroup>

		<PackageReference Include="Aspire.Npgsql.EntityFrameworkCore.PostgreSQL" />

		<PackageReference Include="Grpc.AspNetCore" />
		<PackageReference Include="Grpc.Tools" PrivateAssets="All" />
		<PackageReference Include="Google.Protobuf" />
		<PackageReference Include="Grpc.Net.Client" />
		<PackageReference Include="Grpc.Net.ClientFactory" />
		<PackageReference Include="Microsoft.AspNetCore.OpenApi" />
		<PackageReference Include="Microsoft.VisualStudio.Azure.Containers.Tools.Targets" />
		<PackageReference Include="Swashbuckle.AspNetCore" />
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\ProjectName.Application\ProjectName.Application.csproj" />
		<ProjectReference Include="..\ProjectName.Core\ProjectName.Core.csproj" />
		<ProjectReference Include="..\ProjectName.Infrastructure\ProjectName.Infrastructure.csproj" />
		<ProjectReference Include="..\ProjectName.ServiceDefaults\ProjectName.ServiceDefaults.csproj" />
	</ItemGroup>

</Project>

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.OrchestrationApi\WeatherForecast.cs
------------------------------------------------------------------------------
namespace ProjectName.OrchestrationApi
{
    public class WeatherForecast
    {
        public DateOnly Date { get; set; }

        public int TemperatureC { get; set; }

        public int TemperatureF => 32 + (int)(TemperatureC / 0.5556);

        public string? Summary { get; set; }
    }
}


------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.PlannerService\Properties\launchSettings.json
------------------------------------------------------------------------------
{
  "profiles": {
    "http": {
      "commandName": "Project",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "dotnetRunMessages": true,
      "applicationUrl": "http://localhost:5138"
    },
    "https": {
      "commandName": "Project",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "dotnetRunMessages": true,
      "applicationUrl": "https://localhost:7035;http://localhost:5138"
    },
    "Container (Dockerfile)": {
      "commandName": "Docker",
      "launchUrl": "{Scheme}://{ServiceHost}:{ServicePort}",
      "environmentVariables": {
        "ASPNETCORE_HTTPS_PORTS": "8081",
        "ASPNETCORE_HTTP_PORTS": "8080"
      },
      "publishAllPorts": true,
      "useSSL": true
    }
  },
  "$schema": "https://json.schemastore.org/launchsettings.json"
}

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.PlannerService\Protos\planner.proto
------------------------------------------------------------------------------
syntax = "proto3";

option csharp_namespace = "ProjectName.PlannerService";

package planner;

service Planner {
  rpc CreatePlan (PlanRequest) returns (PlanResponse);
  rpc ValidateOutcome (ValidationRequest) returns (ValidationResponse);
  rpc HealthCheck (HealthCheckRequest) returns (HealthCheckResponse);
}

message PlanRequest {
  string intent = 1;
}

message PlanResponse {
  bool success = 1;
  string goal = 2;
  repeated PlanStepMessage steps = 3;
  string analysis = 4;
  string errorMessage = 5;
}

message PlanStepMessage {
  int32 order = 1;
  string action = 2;
  string tool = 3;
  string argumentsJson = 4;
}

message ValidationRequest {
  string intent = 1;
  string executionLog = 2;
}

message ValidationResponse {
  bool success = 1;
  string validationJson = 2;
  string errorMessage = 3;
}

message HealthCheckRequest {}

message HealthCheckResponse {
  enum ServingStatus {
    UNKNOWN = 0;
    SERVING = 1;
    NOT_SERVING = 2;
  }
  ServingStatus status = 1;
  string message = 2;
}

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.PlannerService\Services\PlannerGrpcService.cs
------------------------------------------------------------------------------
using Grpc.Core;
using ProjectName.Core.Interfaces;
using System.Diagnostics;

namespace ProjectName.PlannerService.Services;

public class PlannerGrpcService : Planner.PlannerBase
{
    private readonly IPlanner _planner;
    private readonly ILogger<PlannerGrpcService> _logger;

    public PlannerGrpcService(IPlanner planner, ILogger<PlannerGrpcService> logger)
    {
        _planner = planner;
        _logger = logger;
    }

    public override async Task<PlanResponse> CreatePlan(
        PlanRequest request,
        ServerCallContext context)
    {
        var sw = Stopwatch.StartNew();
        _logger.LogInformation("CreatePlan called - Intent: {Intent}", request.Intent);

        try
        {
            if (string.IsNullOrWhiteSpace(request.Intent))
            {
                return new PlanResponse { Success = false, ErrorMessage = "Intent cannot be empty" };
            }

            var plan = await _planner.CreatePlanAsync(request.Intent, context.CancellationToken);
            sw.Stop();

            var response = new PlanResponse
            {
                Success = true,
                Goal = plan.Goal,
                Analysis = plan.Analysis
            };

            foreach (var step in plan.Steps)
            {
                response.Steps.Add(new PlanStepMessage
                {
                    Order = step.Order,
                    Action = step.Action,
                    Tool = step.Tool,
                    ArgumentsJson = step.ArgumentsJson
                });
            }

            return response;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error creating plan");
            return new PlanResponse { Success = false, ErrorMessage = ex.Message };
        }
    }

    public override async Task<ValidationResponse> ValidateOutcome(
        ValidationRequest request,
        ServerCallContext context)
    {
        try
        {
            var result = await _planner.ValidateOutcomeAsync(request.Intent, request.ExecutionLog, context.CancellationToken);

            return new ValidationResponse
            {
                Success = true,
                ValidationJson = result
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error validating outcome");
            return new ValidationResponse { Success = false, ErrorMessage = ex.Message };
        }
    }

    public override Task<HealthCheckResponse> HealthCheck(
        HealthCheckRequest request,
        ServerCallContext context)
    {
        return Task.FromResult(new HealthCheckResponse
        {
            Status = HealthCheckResponse.Types.ServingStatus.Serving,
            Message = "Planner service is healthy"
        });
    }
}

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.PlannerService\appsettings.Development.json
------------------------------------------------------------------------------
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}


------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.PlannerService\appsettings.json
------------------------------------------------------------------------------
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "Kestrel": {
    "EndpointDefaults": {
      "Protocols": "Http2"
    }
  },
  "AgentSettings": {
    "OllamaEndpoint": "http://localhost:11434",
    "ModelName": "qwen2.5-coder:latest"
  }
}

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.PlannerService\Dockerfile
------------------------------------------------------------------------------
# See https://aka.ms/customizecontainer to learn how to customize your debug container and how Visual Studio uses this Dockerfile to build your images for faster debugging.

# This stage is used when running from VS in fast mode (Default for Debug configuration)
FROM mcr.microsoft.com/dotnet/aspnet:10.0 AS base
USER $APP_UID
WORKDIR /app
EXPOSE 8080
EXPOSE 8081


# This stage is used to build the service project
FROM mcr.microsoft.com/dotnet/sdk:10.0 AS build
ARG BUILD_CONFIGURATION=Release
WORKDIR /src
COPY ["Directory.Packages.props", "."]
COPY ["Directory.Build.props", "."]
COPY ["Directory.Build.targets", "."]
COPY ["nuget.config", "."]
COPY ["src/ProjectName.PlanerService/ProjectName.PlanerService.csproj", "src/ProjectName.PlanerService/"]
RUN dotnet restore "./src/ProjectName.PlanerService/ProjectName.PlanerService.csproj"
COPY . .
WORKDIR "/src/src/ProjectName.PlanerService"
RUN dotnet build "./ProjectName.PlanerService.csproj" -c $BUILD_CONFIGURATION -o /app/build

# This stage is used to publish the service project to be copied to the final stage
FROM build AS publish
ARG BUILD_CONFIGURATION=Release
RUN dotnet publish "./ProjectName.PlanerService.csproj" -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false

# This stage is used in production or when running from VS in regular mode (Default when not using the Debug configuration)
FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "ProjectName.PlanerService.dll"]

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.PlannerService\Program.cs
------------------------------------------------------------------------------
using Microsoft.Extensions.AI;
using OllamaSharp;
using ProjectName.Infrastructure.Agents;
using ProjectName.PlannerService.Services;
using ProjectName.ServiceDefaults;

var builder = WebApplication.CreateBuilder(args);

builder.AddServiceDefaults();
builder.Services.AddGrpc();

// Get configuration
var ollamaEndpoint = builder.Configuration["AgentSettings:OllamaEndpoint"] ?? "http://localhost:11434";
var modelName = builder.Configuration["AgentSettings:ModelName"] ?? "qwen2.5-coder:latest";

// Register OllamaSharp as IChatClient (implements Microsoft.Extensions.AI)
builder.Services.AddSingleton<IChatClient>(sp =>
{
    var ollamaClient = new OllamaApiClient(
        new Uri(ollamaEndpoint),
        modelName
    );

    // OllamaApiClient implements IChatClient directly
    return ollamaClient;
});

// Register PlannerAgent as the Brain implementation
builder.Services.AddSingleton<ProjectName.Core.Interfaces.IPlanner, PlannerAgent>();

var app = builder.Build();

app.MapGrpcService<PlannerGrpcService>();
app.MapDefaultEndpoints();

app.Run();

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.PlannerService\ProjectName.PlannerService.csproj
------------------------------------------------------------------------------
<Project Sdk="Microsoft.NET.Sdk.Web">
	<PropertyGroup>
		<TargetFramework>net10.0</TargetFramework>
		<Nullable>enable</Nullable>
		<ImplicitUsings>enable</ImplicitUsings>
		<UserSecretsId>96d01d32-0ed9-4755-a32e-d303666266ce</UserSecretsId>
		<DockerDefaultTargetOS>Linux</DockerDefaultTargetOS>
	</PropertyGroup>
	<ItemGroup>
		<Protobuf Include="Protos\planner.proto" GrpcServices="Server" />
	</ItemGroup>
	<ItemGroup>
		<!-- gRPC -->
		<PackageReference Include="Grpc.AspNetCore" />

		<!-- OllamaSharp for LLM -->
		<PackageReference Include="OllamaSharp" />

		<!-- Docker Support -->
		<PackageReference Include="Microsoft.VisualStudio.Azure.Containers.Tools.Targets" />
	</ItemGroup>
	<ItemGroup>
		<ProjectReference Include="..\ProjectName.Core\ProjectName.Core.csproj" />
		<ProjectReference Include="..\ProjectName.Infrastructure\ProjectName.Infrastructure.csproj" />
		<ProjectReference Include="..\ProjectName.ServiceDefaults\ProjectName.ServiceDefaults.csproj" />
	</ItemGroup>
</Project>

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.ServiceDefaults\Extensions.cs
------------------------------------------------------------------------------
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Diagnostics.HealthChecks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Diagnostics.HealthChecks;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using OpenTelemetry;
using OpenTelemetry.Metrics;
using OpenTelemetry.Trace;

namespace ProjectName.ServiceDefaults
{
    // Adds common Aspire services: service discovery, resilience, health checks, and OpenTelemetry.
    // This project should be referenced by each service project in your solution.
    // To learn more about using this project, see https://aka.ms/dotnet/aspire/service-defaults
    public static class Extensions
    {
        private const string HealthEndpointPath = "/health";
        private const string AlivenessEndpointPath = "/alive";

        public static TBuilder AddServiceDefaults<TBuilder>(this TBuilder builder) where TBuilder : IHostApplicationBuilder
        {
            builder.ConfigureOpenTelemetry();

            builder.AddDefaultHealthChecks();

            builder.Services.AddServiceDiscovery();

            builder.Services.ConfigureHttpClientDefaults(http =>
            {
                // Turn on resilience by default
                http.AddStandardResilienceHandler();

                // Turn on service discovery by default
                http.AddServiceDiscovery();
            });

            // Uncomment the following to restrict the allowed schemes for service discovery.
            // builder.Services.Configure<ServiceDiscoveryOptions>(options =>
            // {
            //     options.AllowedSchemes = ["https"];
            // });

            return builder;
        }

        public static TBuilder ConfigureOpenTelemetry<TBuilder>(this TBuilder builder) where TBuilder : IHostApplicationBuilder
        {
            builder.Logging.AddOpenTelemetry(logging =>
            {
                logging.IncludeFormattedMessage = true;
                logging.IncludeScopes = true;
            });

            builder.Services.AddOpenTelemetry()
                .WithMetrics(metrics =>
                {
                    metrics.AddAspNetCoreInstrumentation()
                        .AddHttpClientInstrumentation()
                        .AddRuntimeInstrumentation();
                })
                .WithTracing(tracing =>
                {
                    tracing.AddSource(builder.Environment.ApplicationName)
                        .AddAspNetCoreInstrumentation(tracing =>
                            // Exclude health check requests from tracing
                            tracing.Filter = context =>
                                !context.Request.Path.StartsWithSegments(HealthEndpointPath)
                                && !context.Request.Path.StartsWithSegments(AlivenessEndpointPath)
                        )
                        // Uncomment the following line to enable gRPC instrumentation (requires the OpenTelemetry.Instrumentation.GrpcNetClient package)
                        //.AddGrpcClientInstrumentation()
                        .AddHttpClientInstrumentation();
                });

            builder.AddOpenTelemetryExporters();

            return builder;
        }

        private static TBuilder AddOpenTelemetryExporters<TBuilder>(this TBuilder builder) where TBuilder : IHostApplicationBuilder
        {
            var useOtlpExporter = !string.IsNullOrWhiteSpace(builder.Configuration["OTEL_EXPORTER_OTLP_ENDPOINT"]);

            if (useOtlpExporter)
            {
                builder.Services.AddOpenTelemetry().UseOtlpExporter();
            }

            // Uncomment the following lines to enable the Azure Monitor exporter (requires the Azure.Monitor.OpenTelemetry.AspNetCore package)
            //if (!string.IsNullOrEmpty(builder.Configuration["APPLICATIONINSIGHTS_CONNECTION_STRING"]))
            //{
            //    builder.Services.AddOpenTelemetry()
            //       .UseAzureMonitor();
            //}

            return builder;
        }

        public static TBuilder AddDefaultHealthChecks<TBuilder>(this TBuilder builder) where TBuilder : IHostApplicationBuilder
        {
            builder.Services.AddHealthChecks()
                // Add a default liveness check to ensure app is responsive
                .AddCheck("self", () => HealthCheckResult.Healthy(), ["live"]);

            return builder;
        }

        public static WebApplication MapDefaultEndpoints(this WebApplication app)
        {
            // Adding health checks endpoints to applications in non-development environments has security implications.
            // See https://aka.ms/dotnet/aspire/healthchecks for details before enabling these endpoints in non-development environments.
            if (app.Environment.IsDevelopment())
            {
                // All health checks must pass for app to be considered ready to accept traffic after starting
                app.MapHealthChecks(HealthEndpointPath);

                // Only health checks tagged with the "live" tag must pass for app to be considered alive
                app.MapHealthChecks(AlivenessEndpointPath, new HealthCheckOptions
                {
                    Predicate = r => r.Tags.Contains("live")
                });
            }

            return app;
        }
    }
}


------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\src\ProjectName.ServiceDefaults\ProjectName.ServiceDefaults.csproj
------------------------------------------------------------------------------
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<TargetFramework>net10.0</TargetFramework>
		<ImplicitUsings>enable</ImplicitUsings>
		<Nullable>enable</Nullable>
		<IsAspireSharedProject>true</IsAspireSharedProject>
	</PropertyGroup>

	<ItemGroup>
		<FrameworkReference Include="Microsoft.AspNetCore.App" />

		<!-- NO VERSION ATTRIBUTES - All versions from Directory.Packages.props -->
		<PackageReference Include="Microsoft.Extensions.Http.Resilience" />
		<PackageReference Include="Microsoft.Extensions.ServiceDiscovery" />
		<PackageReference Include="OpenTelemetry.Exporter.OpenTelemetryProtocol" />
		<PackageReference Include="OpenTelemetry.Extensions.Hosting" />
		<PackageReference Include="OpenTelemetry.Instrumentation.AspNetCore" />
		<PackageReference Include="OpenTelemetry.Instrumentation.Http" />
		<PackageReference Include="OpenTelemetry.Instrumentation.Runtime" />
	</ItemGroup>

</Project>

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\Directory.Build.props
------------------------------------------------------------------------------
<Project>

</Project>


------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\Directory.Build.targets
------------------------------------------------------------------------------
<Project>
	
</Project>

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\Directory.Packages.props
------------------------------------------------------------------------------
<Project>
	<PropertyGroup>
		<ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>
		<CentralPackageTransitivePinningEnabled>true</CentralPackageTransitivePinningEnabled>
	</PropertyGroup>

	<ItemGroup>
		<!-- Aspire 13.1.0 -->
		<PackageVersion Include="Aspire.Hosting.AppHost" Version="13.1.0" />
		<PackageVersion Include="Aspire.Hosting.Redis" Version="13.1.0" />
		<PackageVersion Include="Aspire.Hosting.PostgreSQL" Version="13.1.0" />
		<PackageVersion Include="Aspire.Npgsql.EntityFrameworkCore.PostgreSQL" Version="13.1.0" />

		<!-- Microsoft.Extensions.AI (Abstractions) -->
		<PackageVersion Include="Microsoft.Extensions.AI" Version="10.1.1" />
		
		<!-- LLM - OllamaSharp (implements IChatClient) -->
		<PackageVersion Include="OllamaSharp" Version="5.4.12" />

		<!-- Microsoft Extensions 10.0.1 -->
		<PackageVersion Include="Microsoft.Extensions.Hosting" Version="10.0.1" />
		<PackageVersion Include="Microsoft.Extensions.Http" Version="10.0.1" />
		<PackageVersion Include="Microsoft.Extensions.Http.Resilience" Version="10.1.0" />
		<PackageVersion Include="Microsoft.Extensions.ServiceDiscovery" Version="10.1.0" />
		<PackageVersion Include="Microsoft.Extensions.Logging.Abstractions" Version="10.0.1" />
		<PackageVersion Include="Microsoft.Extensions.Configuration" Version="10.0.1" />
		<PackageVersion Include="Microsoft.Extensions.Configuration.Binder" Version="10.0.1" />

		<!-- ASP.NET Core 10 -->
		<PackageVersion Include="Microsoft.AspNetCore.OpenApi" Version="10.0.1" />

		<!-- MCP Protocol -->
		<PackageVersion Include="ModelContextProtocol" Version="0.5.0-preview.1" />
		<PackageVersion Include="ModelContextProtocol.Core" Version="0.5.0-preview.1" />

		<!-- OpenTelemetry 1.14.0 -->
		<PackageVersion Include="OpenTelemetry.Exporter.OpenTelemetryProtocol" Version="1.14.0" />
		<PackageVersion Include="OpenTelemetry.Extensions.Hosting" Version="1.14.0" />
		<PackageVersion Include="OpenTelemetry.Instrumentation.AspNetCore" Version="1.14.0" />
		<PackageVersion Include="OpenTelemetry.Instrumentation.Http" Version="1.14.0" />
		<PackageVersion Include="OpenTelemetry.Instrumentation.Runtime" Version="1.14.0" />

		<!-- gRPC & Protobuf -->
		<PackageVersion Include="Grpc.AspNetCore" Version="2.76.0" />
		<PackageVersion Include="Grpc.Tools" Version="2.76.0" />
		<PackageVersion Include="Grpc.Net.Client" Version="2.76.0" />
		<PackageVersion Include="Grpc.Net.ClientFactory" Version="2.76.0" />
		<PackageVersion Include="Google.Protobuf" Version="3.33.4" />

		<!-- Swagger/OpenAPI -->
		<PackageVersion Include="Swashbuckle.AspNetCore" Version="10.1.0" />

		<!-- Entity Framework Core 10 -->
		<PackageVersion Include="Microsoft.EntityFrameworkCore" Version="10.0.1" />
		<PackageVersion Include="Microsoft.EntityFrameworkCore.Tools" Version="10.0.1" />
		<PackageVersion Include="Npgsql.EntityFrameworkCore.PostgreSQL" Version="10.0.0" />

		<!-- Playwright -->
		<PackageVersion Include="Microsoft.Playwright" Version="1.57.0" />

		<!-- Development & Testing -->
		<PackageVersion Include="Microsoft.VisualStudio.Azure.Containers.Tools.Targets" Version="1.23.0-preview.4" />
	</ItemGroup>
</Project>

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\nuget.config
------------------------------------------------------------------------------
<?xml version="1.0" encoding="utf-8"?>
<configuration>
	<packageSources>
		<clear />
		<add key="nuget.org" value="https://api.nuget.org/v3/index.json" protocolVersion="3" />
		<add key="Telerik" value="https://nuget.telerik.com/v3/index.json" />
	</packageSources>

	<!-- 
		SOURCE MAPPING:
		Prevents package hijacking and source ambiguity.
	-->
	<packageSourceMapping>
		<packageSource key="nuget.org">
			<package pattern="*" />
		</packageSource>
		<packageSource key="Telerik">
			<package pattern="Telerik.*" />
			<package pattern="Kendo.*" />
		</packageSource>
	</packageSourceMapping>

	<!-- 
		REMOVED LOCAL PACKAGES FOLDER
		This was causing path length issues on Windows.
		Packages now use global cache: %USERPROFILE%\.nuget\packages
	-->

</configuration>

------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\ProjectName.sln
------------------------------------------------------------------------------

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 18
VisualStudioVersion = 18.3.11312.210
MinimumVisualStudioVersion = 10.0.40219.1
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "src", "src", "{827E0CD3-B72D-47B6-A68D-7590B98EB39B}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ProjectName.AppHost", "src\ProjectName.AppHost\ProjectName.AppHost.csproj", "{C5234D3D-E468-4276-B130-46EE16A01640}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ProjectName.McpServer", "src\ProjectName.McpServer\ProjectName.McpServer.csproj", "{185DFFC4-F29C-4408-8166-B8424ECB074D}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ProjectName.Core", "src\ProjectName.Core\ProjectName.Core.csproj", "{EEC0FF8F-E4BA-4AC3-A451-3661D45CA161}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ProjectName.Infrastructure", "src\ProjectName.Infrastructure\ProjectName.Infrastructure.csproj", "{DC839416-E123-4D11-B136-735E6E3D141E}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ProjectName.ServiceDefaults", "src\ProjectName.ServiceDefaults\ProjectName.ServiceDefaults.csproj", "{59BE09D2-BE58-4942-BC69-6EBD7F306FAA}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ProjectName.OrchestrationApi", "src\ProjectName.OrchestrationApi\ProjectName.OrchestrationApi.csproj", "{DF5CBE0E-6707-4947-A986-3526E40E52F2}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ProjectName.Application", "src\ProjectName.Application\ProjectName.Application.csproj", "{6CBDEC11-506A-41F6-91F3-2F4C22800192}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ProjectName.PlannerService", "src\ProjectName.PlannerService\ProjectName.PlannerService.csproj", "{137722EC-2258-56BB-AAB8-33A20BD6AD4D}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|Any CPU = Release|Any CPU
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{C5234D3D-E468-4276-B130-46EE16A01640}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{C5234D3D-E468-4276-B130-46EE16A01640}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{C5234D3D-E468-4276-B130-46EE16A01640}.Debug|x64.ActiveCfg = Debug|Any CPU
		{C5234D3D-E468-4276-B130-46EE16A01640}.Debug|x64.Build.0 = Debug|Any CPU
		{C5234D3D-E468-4276-B130-46EE16A01640}.Debug|x86.ActiveCfg = Debug|Any CPU
		{C5234D3D-E468-4276-B130-46EE16A01640}.Debug|x86.Build.0 = Debug|Any CPU
		{C5234D3D-E468-4276-B130-46EE16A01640}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{C5234D3D-E468-4276-B130-46EE16A01640}.Release|Any CPU.Build.0 = Release|Any CPU
		{C5234D3D-E468-4276-B130-46EE16A01640}.Release|x64.ActiveCfg = Release|Any CPU
		{C5234D3D-E468-4276-B130-46EE16A01640}.Release|x64.Build.0 = Release|Any CPU
		{C5234D3D-E468-4276-B130-46EE16A01640}.Release|x86.ActiveCfg = Release|Any CPU
		{C5234D3D-E468-4276-B130-46EE16A01640}.Release|x86.Build.0 = Release|Any CPU
		{185DFFC4-F29C-4408-8166-B8424ECB074D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{185DFFC4-F29C-4408-8166-B8424ECB074D}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{185DFFC4-F29C-4408-8166-B8424ECB074D}.Debug|x64.ActiveCfg = Debug|Any CPU
		{185DFFC4-F29C-4408-8166-B8424ECB074D}.Debug|x64.Build.0 = Debug|Any CPU
		{185DFFC4-F29C-4408-8166-B8424ECB074D}.Debug|x86.ActiveCfg = Debug|Any CPU
		{185DFFC4-F29C-4408-8166-B8424ECB074D}.Debug|x86.Build.0 = Debug|Any CPU
		{185DFFC4-F29C-4408-8166-B8424ECB074D}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{185DFFC4-F29C-4408-8166-B8424ECB074D}.Release|Any CPU.Build.0 = Release|Any CPU
		{185DFFC4-F29C-4408-8166-B8424ECB074D}.Release|x64.ActiveCfg = Release|Any CPU
		{185DFFC4-F29C-4408-8166-B8424ECB074D}.Release|x64.Build.0 = Release|Any CPU
		{185DFFC4-F29C-4408-8166-B8424ECB074D}.Release|x86.ActiveCfg = Release|Any CPU
		{185DFFC4-F29C-4408-8166-B8424ECB074D}.Release|x86.Build.0 = Release|Any CPU
		{EEC0FF8F-E4BA-4AC3-A451-3661D45CA161}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{EEC0FF8F-E4BA-4AC3-A451-3661D45CA161}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{EEC0FF8F-E4BA-4AC3-A451-3661D45CA161}.Debug|x64.ActiveCfg = Debug|Any CPU
		{EEC0FF8F-E4BA-4AC3-A451-3661D45CA161}.Debug|x64.Build.0 = Debug|Any CPU
		{EEC0FF8F-E4BA-4AC3-A451-3661D45CA161}.Debug|x86.ActiveCfg = Debug|Any CPU
		{EEC0FF8F-E4BA-4AC3-A451-3661D45CA161}.Debug|x86.Build.0 = Debug|Any CPU
		{EEC0FF8F-E4BA-4AC3-A451-3661D45CA161}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{EEC0FF8F-E4BA-4AC3-A451-3661D45CA161}.Release|Any CPU.Build.0 = Release|Any CPU
		{EEC0FF8F-E4BA-4AC3-A451-3661D45CA161}.Release|x64.ActiveCfg = Release|Any CPU
		{EEC0FF8F-E4BA-4AC3-A451-3661D45CA161}.Release|x64.Build.0 = Release|Any CPU
		{EEC0FF8F-E4BA-4AC3-A451-3661D45CA161}.Release|x86.ActiveCfg = Release|Any CPU
		{EEC0FF8F-E4BA-4AC3-A451-3661D45CA161}.Release|x86.Build.0 = Release|Any CPU
		{DC839416-E123-4D11-B136-735E6E3D141E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{DC839416-E123-4D11-B136-735E6E3D141E}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{DC839416-E123-4D11-B136-735E6E3D141E}.Debug|x64.ActiveCfg = Debug|Any CPU
		{DC839416-E123-4D11-B136-735E6E3D141E}.Debug|x64.Build.0 = Debug|Any CPU
		{DC839416-E123-4D11-B136-735E6E3D141E}.Debug|x86.ActiveCfg = Debug|Any CPU
		{DC839416-E123-4D11-B136-735E6E3D141E}.Debug|x86.Build.0 = Debug|Any CPU
		{DC839416-E123-4D11-B136-735E6E3D141E}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{DC839416-E123-4D11-B136-735E6E3D141E}.Release|Any CPU.Build.0 = Release|Any CPU
		{DC839416-E123-4D11-B136-735E6E3D141E}.Release|x64.ActiveCfg = Release|Any CPU
		{DC839416-E123-4D11-B136-735E6E3D141E}.Release|x64.Build.0 = Release|Any CPU
		{DC839416-E123-4D11-B136-735E6E3D141E}.Release|x86.ActiveCfg = Release|Any CPU
		{DC839416-E123-4D11-B136-735E6E3D141E}.Release|x86.Build.0 = Release|Any CPU
		{59BE09D2-BE58-4942-BC69-6EBD7F306FAA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{59BE09D2-BE58-4942-BC69-6EBD7F306FAA}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{59BE09D2-BE58-4942-BC69-6EBD7F306FAA}.Debug|x64.ActiveCfg = Debug|Any CPU
		{59BE09D2-BE58-4942-BC69-6EBD7F306FAA}.Debug|x64.Build.0 = Debug|Any CPU
		{59BE09D2-BE58-4942-BC69-6EBD7F306FAA}.Debug|x86.ActiveCfg = Debug|Any CPU
		{59BE09D2-BE58-4942-BC69-6EBD7F306FAA}.Debug|x86.Build.0 = Debug|Any CPU
		{59BE09D2-BE58-4942-BC69-6EBD7F306FAA}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{59BE09D2-BE58-4942-BC69-6EBD7F306FAA}.Release|Any CPU.Build.0 = Release|Any CPU
		{59BE09D2-BE58-4942-BC69-6EBD7F306FAA}.Release|x64.ActiveCfg = Release|Any CPU
		{59BE09D2-BE58-4942-BC69-6EBD7F306FAA}.Release|x64.Build.0 = Release|Any CPU
		{59BE09D2-BE58-4942-BC69-6EBD7F306FAA}.Release|x86.ActiveCfg = Release|Any CPU
		{59BE09D2-BE58-4942-BC69-6EBD7F306FAA}.Release|x86.Build.0 = Release|Any CPU
		{DF5CBE0E-6707-4947-A986-3526E40E52F2}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{DF5CBE0E-6707-4947-A986-3526E40E52F2}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{DF5CBE0E-6707-4947-A986-3526E40E52F2}.Debug|x64.ActiveCfg = Debug|Any CPU
		{DF5CBE0E-6707-4947-A986-3526E40E52F2}.Debug|x64.Build.0 = Debug|Any CPU
		{DF5CBE0E-6707-4947-A986-3526E40E52F2}.Debug|x86.ActiveCfg = Debug|Any CPU
		{DF5CBE0E-6707-4947-A986-3526E40E52F2}.Debug|x86.Build.0 = Debug|Any CPU
		{DF5CBE0E-6707-4947-A986-3526E40E52F2}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{DF5CBE0E-6707-4947-A986-3526E40E52F2}.Release|Any CPU.Build.0 = Release|Any CPU
		{DF5CBE0E-6707-4947-A986-3526E40E52F2}.Release|x64.ActiveCfg = Release|Any CPU
		{DF5CBE0E-6707-4947-A986-3526E40E52F2}.Release|x64.Build.0 = Release|Any CPU
		{DF5CBE0E-6707-4947-A986-3526E40E52F2}.Release|x86.ActiveCfg = Release|Any CPU
		{DF5CBE0E-6707-4947-A986-3526E40E52F2}.Release|x86.Build.0 = Release|Any CPU
		{6CBDEC11-506A-41F6-91F3-2F4C22800192}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{6CBDEC11-506A-41F6-91F3-2F4C22800192}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{6CBDEC11-506A-41F6-91F3-2F4C22800192}.Debug|x64.ActiveCfg = Debug|Any CPU
		{6CBDEC11-506A-41F6-91F3-2F4C22800192}.Debug|x64.Build.0 = Debug|Any CPU
		{6CBDEC11-506A-41F6-91F3-2F4C22800192}.Debug|x86.ActiveCfg = Debug|Any CPU
		{6CBDEC11-506A-41F6-91F3-2F4C22800192}.Debug|x86.Build.0 = Debug|Any CPU
		{6CBDEC11-506A-41F6-91F3-2F4C22800192}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{6CBDEC11-506A-41F6-91F3-2F4C22800192}.Release|Any CPU.Build.0 = Release|Any CPU
		{6CBDEC11-506A-41F6-91F3-2F4C22800192}.Release|x64.ActiveCfg = Release|Any CPU
		{6CBDEC11-506A-41F6-91F3-2F4C22800192}.Release|x64.Build.0 = Release|Any CPU
		{6CBDEC11-506A-41F6-91F3-2F4C22800192}.Release|x86.ActiveCfg = Release|Any CPU
		{6CBDEC11-506A-41F6-91F3-2F4C22800192}.Release|x86.Build.0 = Release|Any CPU
		{137722EC-2258-56BB-AAB8-33A20BD6AD4D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{137722EC-2258-56BB-AAB8-33A20BD6AD4D}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{137722EC-2258-56BB-AAB8-33A20BD6AD4D}.Debug|x64.ActiveCfg = Debug|Any CPU
		{137722EC-2258-56BB-AAB8-33A20BD6AD4D}.Debug|x64.Build.0 = Debug|Any CPU
		{137722EC-2258-56BB-AAB8-33A20BD6AD4D}.Debug|x86.ActiveCfg = Debug|Any CPU
		{137722EC-2258-56BB-AAB8-33A20BD6AD4D}.Debug|x86.Build.0 = Debug|Any CPU
		{137722EC-2258-56BB-AAB8-33A20BD6AD4D}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{137722EC-2258-56BB-AAB8-33A20BD6AD4D}.Release|Any CPU.Build.0 = Release|Any CPU
		{137722EC-2258-56BB-AAB8-33A20BD6AD4D}.Release|x64.ActiveCfg = Release|Any CPU
		{137722EC-2258-56BB-AAB8-33A20BD6AD4D}.Release|x64.Build.0 = Release|Any CPU
		{137722EC-2258-56BB-AAB8-33A20BD6AD4D}.Release|x86.ActiveCfg = Release|Any CPU
		{137722EC-2258-56BB-AAB8-33A20BD6AD4D}.Release|x86.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{C5234D3D-E468-4276-B130-46EE16A01640} = {827E0CD3-B72D-47B6-A68D-7590B98EB39B}
		{185DFFC4-F29C-4408-8166-B8424ECB074D} = {827E0CD3-B72D-47B6-A68D-7590B98EB39B}
		{EEC0FF8F-E4BA-4AC3-A451-3661D45CA161} = {827E0CD3-B72D-47B6-A68D-7590B98EB39B}
		{DC839416-E123-4D11-B136-735E6E3D141E} = {827E0CD3-B72D-47B6-A68D-7590B98EB39B}
		{59BE09D2-BE58-4942-BC69-6EBD7F306FAA} = {827E0CD3-B72D-47B6-A68D-7590B98EB39B}
		{DF5CBE0E-6707-4947-A986-3526E40E52F2} = {827E0CD3-B72D-47B6-A68D-7590B98EB39B}
		{6CBDEC11-506A-41F6-91F3-2F4C22800192} = {827E0CD3-B72D-47B6-A68D-7590B98EB39B}
		{137722EC-2258-56BB-AAB8-33A20BD6AD4D} = {827E0CD3-B72D-47B6-A68D-7590B98EB39B}
	EndGlobalSection
EndGlobal


------------------------------------------------------------------------------
FILE: T:\agents\ProjectName\README.md
------------------------------------------------------------------------------
# PMCR-O Agent Framework - .NET 10 + Microsoft Agent Framework (MAF)

## Architecture Overview

This is a **Hybrid REST + gRPC** microservices architecture implementing the **PMCR-O** (Plan-Make-Check-Reflect-Orchestrate) cognitive framework using **Microsoft Agent Framework (MAF)** and Clean Architecture principles.

### Why Microsoft Agent Framework (MAF)?

This implementation uses **Microsoft.Agents.AI** instead of raw `Microsoft.Extensions.AI` because:

1. **Built-in Agent Patterns** - MAF provides `Agent` class with identity, instructions, and capabilities
2. **Context Management** - `AgentContext` for maintaining conversation state and session tracking
3. **Tool Integration** - Native support for function calling and tool orchestration
4. **Multi-Agent Coordination** - Framework for agent collaboration and handoff
5. **Enterprise Ready** - Production-grade abstractions for Teams, Azure, and enterprise scenarios

### Components

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         .NET Aspire AppHost                        â”‚
â”‚    (Orchestration + Service Discovery)             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
    â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚            â”‚         â”‚          â”‚           â”‚
    â–¼            â–¼         â–¼          â–¼           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ REST   â”‚  â”‚ gRPC   â”‚ â”‚Redis â”‚ â”‚Postgres â”‚ â”‚Playwrightâ”‚
â”‚ API    â”‚â”€â”€â”‚Planner â”‚ â”‚Cache â”‚ â”‚Database â”‚ â”‚Browser  â”‚
â”‚Gateway â”‚  â”‚Service â”‚ â””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚:7269   â”‚  â”‚:7035   â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”˜
     â”‚           â”‚
     â”‚           â–¼
     â”‚      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚      â”‚ Ollama  â”‚
     â”‚      â”‚ LLM     â”‚
     â”‚      â”‚:11434   â”‚
     â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Playwright  â”‚
â”‚ MCP Tools   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Key Technologies

- **.NET Aspire** - Distributed application orchestration, service discovery, telemetry
- **Microsoft Agent Framework (MAF)** - Agent patterns, context management, tool integration
- **gRPC** - High-performance internal RPC
- **REST API** - External HTTP gateway with Swagger
- **MCP (Model Context Protocol)** - Tool server for browser automation
- **Playwright** - Headless browser automation
- **Redis** - Distributed caching and session state
- **PostgreSQL** - Cognitive trail persistence
- **Ollama** - Local LLM inference


